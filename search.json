[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About VCF",
    "section": "",
    "text": "YouTube\n  \n  \n    \n     Github\n  \n  \n    \n     Twitter\n  \n\n  \n  \n\n\nVCF is a blog dedicated to coding in Python for empirical research in finance with a companion YouTube channel. My goal is to provide a platform for sharing knowledge and resources about coding in finance. The content is aimed at students, academics, and finance professionals who want to learn more about coding and empirical finance research.\nI use this platform to complement my teaching material and make it available to a wider audience. I also use it to share my experience with coding in finance and to document my journey as I learn new things."
  },
  {
    "objectID": "about.html#about-vincent-codes-finance",
    "href": "about.html#about-vincent-codes-finance",
    "title": "About VCF",
    "section": "",
    "text": "VCF is a blog dedicated to coding in Python for empirical research in finance with a companion YouTube channel. My goal is to provide a platform for sharing knowledge and resources about coding in finance. The content is aimed at students, academics, and finance professionals who want to learn more about coding and empirical finance research.\nI use this platform to complement my teaching material and make it available to a wider audience. I also use it to share my experience with coding in finance and to document my journey as I learn new things."
  },
  {
    "objectID": "about.html#contact",
    "href": "about.html#contact",
    "title": "About VCF",
    "section": "Contact",
    "text": "Contact\nFor any comments and inquiries about this blog or the YouTube Channel, please contact me at:\nEMAIL: vincent@codes.finance"
  },
  {
    "objectID": "about.html#about-vincent",
    "href": "about.html#about-vincent",
    "title": "About VCF",
    "section": "About Vincent",
    "text": "About Vincent\n\n\nHello, my name is Vincent Gr√©goire. I‚Äôm an Associate Professor of Finance at HEC Montr√©al where I have been teaching Empirical Finance at the Master‚Äôs for a couple of years. My research interests include information economics, market microstructure, big data and machine learning applications in finance, fintech, and cybersecurity in finance. I‚Äôm also a Python enthusiast and curious about anything related to coding, data science, and machine learning.\n\n\n\n\n\n\n\n\nMy academic journey led me from undergraduate and master‚Äôs degrees in Computer Engineering to a Master‚Äôs in Financial Engineering at Universit√© Laval and a Ph.D.¬†in Finance from the University of British Columbia.\nSee my academic page for more details."
  },
  {
    "objectID": "about.html#license-and-reuse",
    "href": "about.html#license-and-reuse",
    "title": "About VCF",
    "section": "üîì License and reuse",
    "text": "üîì License and reuse\nAll content on this website is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. You are free to share and adapt the material for non-commercial purposes as long as you give appropriate credit and distribute your contributions under the same license.\nIf you want to reuse any of the content on this website for teaching purposes, please feel free to do so. I would appreciate it if you could include a link to this website in your course material and let me know by sending me an email at vincent@codes.finance. I will be happy to provide you with the source files for any of the content on this website upon request.\nIf for any reason you would like to reuse any of the content on this website for a purpose that is not covered by the above license, please contact me at vincent@codes.finance.\nThe code examples on this website are available on GitHub under the MIT License. You are free to use the code for any purpose, including commercial purposes, as long as you give appropriate credit and include a copy of the license in your distribution."
  },
  {
    "objectID": "about.html#how-is-this-blog-built",
    "href": "about.html#how-is-this-blog-built",
    "title": "About VCF",
    "section": "üõ†Ô∏è How is this blog built?",
    "text": "üõ†Ô∏è How is this blog built?\nThis website is built using Quarto, an open-source document system that allows you to write content in Markdown or Jupyter Notebooks and publish it in a variety of formats, including static HTML files. Quarto is on my list of topics to cover in the future, so stay tuned for more content on that topic.\nThe blog is currently hosted using GitHub Pages."
  },
  {
    "objectID": "about.html#monetization",
    "href": "about.html#monetization",
    "title": "About VCF",
    "section": "ü§ë Monetization",
    "text": "ü§ë Monetization\nAs we move forward, I promise to maintain transparency, especially concerning any potential monetization avenues. At the moment, I do not monetize this website or the YouTube channel. That might change in the future, but I will always be transparent about it."
  },
  {
    "objectID": "about.html#use-of-ai",
    "href": "about.html#use-of-ai",
    "title": "About VCF",
    "section": "ü§ñ Use of AI",
    "text": "ü§ñ Use of AI\nWhile I make use of AI-powered tools for editing and proofreading, I am committed to ensuring that all content is original and accurate. I will always cite my sources and give credit where credit is due."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html",
    "href": "intro-to-python/python-basics/index.html",
    "title": "Python Basics",
    "section": "",
    "text": "In this tutorial, we lay the foundation for your programming skills by exploring the basic syntax of Python.\nMy aim is to make this process as accessible as possible for non-programmers while giving you the necessary tools to excel in the world of empirical finance research.\nThe objectives of this tutorial are to:\nBy the end of this tutorial, you will have a solid grasp of Python‚Äôs basic syntax, empowering you to use it as a versatile tool for finance-related tasks. Remember, the key to success in learning any programming language is practice. As you work through this tutorial, be sure to experiment with the examples provided and try writing your own code to reinforce your understanding.\nI am purposefully avoiding more advanced topics such as object-oriented programming, functional programming, and parallel computing. These topics are important, but they are not necessary to get started with Python. I will cover these topics in future tutorials.\nAfter completing this tutorial, you will be ready to move on to the next tutorial in this series, Introduction to data analysis in Python using pandas 2.1 (coming soon), where we will explore how to use Python to explore and study financial data.\nLet‚Äôs dive into the world of Python and begin your journey toward becoming a proficient financial empiricist."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#prerequisites",
    "href": "intro-to-python/python-basics/index.html#prerequisites",
    "title": "Python Basics",
    "section": "Prerequisites",
    "text": "Prerequisites\nThis tutorial assumes no prior knowledge of Python or programming in general. However, it is helpful to have some familiarity with basic mathematical concepts such as functions, variables, and equations. Because most of the examples in this tutorial are related to finance, it is also helpful to have some basic knowledge of finance and economics. However, this is not a requirement.\nThis tutorial does not cover the installation of Python. If you have not already installed Python, you can refer to my previous post on how to install Python 3.12."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#video-tutorials",
    "href": "intro-to-python/python-basics/index.html#video-tutorials",
    "title": "Python Basics",
    "section": "Video tutorials",
    "text": "Video tutorials\nI am currently working on a series of video tutorials that will accompany this tutorial. The videos will be available on my YouTube channel and will be linked to the relevant sections of this tutorial when they are available."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#data-types",
    "href": "intro-to-python/python-basics/index.html#data-types",
    "title": "Python Basics",
    "section": "Data types",
    "text": "Data types\nThe Python language offers many built-in fundamental data types. These data types serve as the building blocks for working with different kinds of data, which is critical in many applications. The basic data types you should be familiar with are presented in Table¬†1.\n\n\nTable¬†1: Main data types in Python\n\n\n\n\n\n\n\n\nName\nType\nDescription\nExample\n\n\n\n\nInteger\nint\nIntegers represent whole positive and negative numbers. They are used for counting, indexing, and various arithmetic operations.\n1\n\n\nFloat-Point Number\nfloat\nFloats represent real numbers with decimals. They are used for working with financial data that require precision, such as interest rates, stock prices, and percentages.\n1.0\n\n\nComplex\ncomplex\nComplex numbers consist of real and imaginary parts, represented as a + bj. While less commonly used in finance, they may be relevant in specific advanced applications, such as signal processing or quantitative finance.\n1.0 + 2.0j\n\n\nBoolean\nbool\nBooleans represent the truth values of True and False. They are used in conditional statements, comparisons, and other logical operations.\nTrue\n\n\nText String\nstr\nStrings are sequences of characters used for storing and manipulating text data, such as stock symbols, company names, or descriptions.\n\"Hello\"\n\n\nBytes\nbytes\nBytes are sequences of integers in the range of 0-255, often used for representing binary data or encoding text. Bytes may be used when working with binary file formats or network communication.\nb\"Hello\"\n\n\nNone\nNone\nNone is a special data type representing the absence of a value or a null value. It is used to signify that a variable has not been assigned a value or that a function returns no value.\nNone\n\n\n\n\n\nLiterals\nA literal is a notation for representing a fixed value in source code. For example, 42 is a literal for the integer value of forty-two. The following are examples of literals in Python. Each code block contains code and is followed by the output of the code.\n\nint\nint literals are written as positive and negative whole numbers.\n\n42\n\n42\n\n\n\n-99\n\n-99\n\n\nThey can also include underscores to make them more readable.\n\n1_000_000\n\n1000000\n\n\n\n\nfloat\nfloat literals are written as decimal numbers.\n\n2.25\n\n2.25\n\n\nThey can be written in scientific notation by using e to indicate the exponent.\n\n2.25e8\n\n225000000.0\n\n\nTo define a whole number literal as a float instead of an int, you can append a decimal point to the number.\n\n2.0\n\n2.0\n\n\n\n\ncomplex\nComplex numbers consist of a real part and an imaginary part, represented as a + bj.\n\n2.3 + 4.5j\n\n(2.3+4.5j)\n\n\n\n\nNone\nNone is a special data type that represents the absence of a value or a null value. It is used to signify that a variable has not been assigned a value or that a function returns no value.\n\nNone\n\n\n\nbool\nbool is a data type that represents the truth values of True and False. They are used in conditional statements, comparisons, and other logical operations.\n\nTrue\n\nTrue\n\n\n\n\n\nstr\nStrings are sequences of characters. Strings literals are written by enclosing a sequence of characters in single or double quotes. Note that doubles quotes are preferred by the black code formatter, which is used in this book, but most Python environments will use single quotes by default when displaying strings.\n\n\"USD\"\n\n'USD'\n\n\nStrings are sequences of Unicode characters, which means they can represent any character in any language.\n\n\"Bitcoin  üöÄ\"\n\n'Bitcoin  üöÄ'\n\n\nString literals can span multiple lines by enclosing them in triple quotes or triple double quotes. This is useful for writing multiline strings.\n\n# Multiline strings\n\n\"\"\"GAFA is a group of companies:\n\n- Google\n- Apple\n- Facebook\n- Amazon\n\n\"\"\"\n\n'GAFA is a group of companies:\\n\\n- Google\\n- Apple\\n- Facebook\\n- Amazon\\n\\n'\n\n\nMultiline strings, or any strings with special characters, can be displayed using the print function.\n\nprint(\n    \"\"\"GAFA is a group of companies:\n\n- Google\n- Apple\n- Facebook\n- Amazon\n\n\"\"\"\n)\n\nGAFA is a group of companies:\n\n- Google\n- Apple\n- Facebook\n- Amazon\n\n\n\n\n\n\nbytes\nbytes are sequences of integers in the range of 0-255. They are often used for representing binary data or encoding text. Bytes literals are written by prepending a string literal with b.\n\nb\"Hello\"\n\nb'Hello'\n\n\n\n\n\n\n\n\nBytes vs strings\n\n\n\nBytes can be confused with strings, but they are not the same. Strings are sequences of Unicode characters, while bytes are sequences of integers in the range of 0-255. Bytes are often used for representing binary data or encoding text. In most cases, you will be working with strings, but you may encounter bytes when working with binary file formats or network communication."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#variables",
    "href": "intro-to-python/python-basics/index.html#variables",
    "title": "Python Basics",
    "section": "Variables",
    "text": "Variables\nA variable in Python is a named location in the computer‚Äôs memory that holds a value. It serves as a container for data, allowing you to reference and manipulate the data stored within it. Variables are created by assigning a value to a name using the assignment operator (=). They can store data of various types, such as integers, floats, strings, or even more complex data structures like lists.\nUnderstanding the concept of variables and their naming conventions will help you write clean, readable, and maintainable code. An overview of variable naming rules in Python is presented in Table¬†2, and Table¬†3 presents some examples of valid and invalid variable names.\n\n\nTable¬†2: Variable naming rules\n\n\n\n\n\n\nRule\nDescription\n\n\n\n\nCan contain letters, numbers, and underscores\nVariable names can include any combination of letters (both uppercase and lowercase), numbers, and underscores (_). Python variable names support Unicode characters, enabling you to use non-English characters in your variable names. However, they must follow the other rules mentioned below.\n\n\nCannot start with a number\nAlthough variable names can contain numbers, they must not begin with a number. For example, 1_stock is an invalid variable name, whereas stock_1 is valid.\n\n\nCannot be a reserved word\nPython has a set of reserved words (e.g., if, else, while) that have special meanings within the language. You should not use these words as variable names.\n\n\n\n\n\n\nTable¬†3: Variable naming examples\n\n\nValid\nInvalid\n\n\n\n\nticker\n1ceo\n\n\nfirm_size\n@price\n\n\ntotal_sum_2023\nclass\n\n\n_tmp_buffer\nfor\n\n\n\n\n\n\n\n\n\n\nCase-sensitive\n\n\n\nPython is case-sensitive, so ret and RET are two different variables.\n\n\nBeyond the rules mentioned above, there are also some conventions that you should follow when naming variables. These conventions are not enforced by Python, but they are widely adopted by the Python community. Table¬†4 summarizes the most common conventions.\n\n\nTable¬†4: Variable naming conventions\n\n\n\n\n\n\nConvention\nDescription\n\n\n\n\nUse lowercase letters and underscores for variable names\nTo enhance code readability, use lowercase letters for variable names and separate words with underscores. For example, market_cap is a recommended variable name, whereas MarketCap or marketCap are not. This naming convention is known as snake case.\n\n\nUse uppercase letters for constants\nConstants are values that do not change throughout the program. Use uppercase letters and separate words with underscores to differentiate them from regular variables. For example, INFLATION_TARGET is a suitable constant name. Note that Python does not support constants like other languages, so this is just a convention, but Python won‚Äôt stop you from changing the value of a constant.\n\n\n\n\nBy adhering to these guidelines, you will improve your coding style and ensure that your code is easier to understand, maintain, and collaborate on with your peers.\n\n\n\n\n\n\nReserved keywords\n\n\n\nReserved keywords cannot be used as variable names. You can check the complete list of reserved keywords by running the following command in the Python console:\n\nhelp(\"keywords\")\n\n\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\nFalse               class               from                or\nNone                continue            global              pass\nTrue                def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\nbreak               for                 not                 \n\n\n\nNote that some reserved keywords may be confusing when thinking about finance problems. For example, return, yield, raise, global, class, and lambda are all reserved keywords, so you cannot use them as variable names. Most modern IDEs, such as Visual Studio Code, will highlight reserved keywords in a different color to help you avoid using them as variable names.\n\n\n\nDeclaring variables\nA simple way to think about variables is to consider them labels that you can use to refer to values. For example, you can create a variable x and assign it a value of 42 using the assignment operator (=). You can then use the variable x to refer to the value 42 in your code.\n\nx = 42\nx\n\n42\n\n\n\n\n\n\n\n\nThe walrus operator\n\n\n\nIn the previous example, we added x to the last line of the code to display the value of x. This is necessary in the interactive window and in Jupyer Notebooks, as they automatically display the result of the last line of the code. However, the assignment operator (=) does not return a value, so the value of x is not displayed without that last line.\n\nx = 42\n\nIntroduced in Python 3.8, the := operator, also known as the walrus operator, allows you to assign a value to a variable and return that value in a single expression. For example, you can use the walrus operator to assign a value of 10 to a variable z and use that variable in the same expression, assigning the result to y.\n\ny = (z := 10) * 2\n\nNote, however, that the walrus operator cannot be used to assign a value to a variable without using it in an expression. For example, the following code will raise an error.\n\nx := 42\n\nSyntaxError: invalid syntax (4042238066.py, line 1)\n\n\n\n\nYou can reassign the value of a variable by assigning a new value to it. Once you reassign the value of a variable, the old value is lost. For example, you can reassign the value of x to 32 by running the following code.\n\nx = 32\nx\n\n32\n\n\nYou can perform operations on variables, just like you would on values. For example, you can add 10 to x.\n\nx + 10\n\n42\n\n\nYou can assign the result of an operation to a new variable. For example, you can assign the result of 2 * 10 to a new variable y.\n\ny = 2 * x\ny\n\n64\n\n\n\nz = x + y\nz\n\n96\n\n\nIf you try to use a variable name that is invalid, Python will raise an error. For example, if you try to assign a variable 1ceo, Python will raise an error because variable names cannot start with a number.\n\n1ceo = 2\n\nSyntaxError: invalid decimal literal (1479589190.py, line 1)\n\n\nYou can, however, use Unicode characters in variable names. For example, you can use accents such as √© in a variable name.\n\ncote_de_cr√©dit = \"AAA\"\n\nA leading underscore in a variable name indicates that the variable is private, which means that it should not be accessed outside of the module or scope in which it is defined. For example, you can use a leading underscore in a variable name to indicate that the variable is private. This is a convention that is widely adopted by the Python community, but it is not enforced by Python.\n\n_hidden = 30_000\n\nAnother convention is to use all caps for constants. For example, you can use all caps to indicate that INFLATION_TARGET is a constant.\n\nINFLATION_TARGET = 0.02\n\nPython will raise an error if you attempt to use a variable that has not been declared. For instance, if you try to use the variable inflation_target instead of INFLATION_TARGET, Python will generate an error. It‚Äôs important to note that Python is case-sensitive, so variables must be referenced with the exact casing as their declaration.\n\ninflation_target\n\nNameError: name 'inflation_target' is not defined\n\n\n\n\nVariable types\nPython is a dynamically typed language, meaning you do not need to specify the variable type when you declare it. Instead, Python will automatically infer the type of a variable based on the value you assign to it. For example, if you assign an integer value to a variable, Python will infer that the variable is an integer. Similarly, if you assign a string value to a variable, Python will infer that the variable is a string. You can use the type() function to check the type of a variable. For example, you can check the type of a by running the following code.\n\na = 3.3\ntype(a)\n\nfloat\n\n\n\nb = 2\ntype(b)\n\nint\n\n\n\nmarket_open = True\ntype(market_open)\n\nbool\n\n\n\ncurrency = \"CAD\"\ntype(currency)\n\nstr\n\n\n\n\n\n\n\n\nVariables explorer in Visual Studio Code\n\n\n\nVS Code has a built-in variable explorer that allows you to view the variables in your workspace when using the interactive window or a Jupyer Notebook. You can open the Variables View by clicking on the Variables button in the top toolbar of the editor:\n\n\n\nVariable View button\n\n\nThe Variables View will appear at the bottom of the window, showing the variables in your workspace, along with their values, types, and size for collections. For example, the following screenshot shows the variables in the workspace after running the code in this section:\n\n\n\nVariable View\n\n\n\n\n\nConverting between types\nYou can convert a variable from one type to another using the built-in functions float(), int(), str(), and bool(). For example, you can convert the variable x, which is currently an int, to a float by running the following code.\n\nfloat(x)\n\n32.0\n\n\nThe same way, you can convert the variable y, which is currently a float, to an int by running the following code. Note that the int() function will round down the value of y to the nearest integer.\n\nint(a)\n\n3\n\n\nSimilarly, you can convert the variable x to a string by running the following code.\n\nstr(x)\n\n'32'\n\n\nYou can convert a string to an integer or a float if the string contains a valid representation of a number. For example, you can convert the string \"42\" to an integer by running the following code.\n\nint('42')\n\n42\n\n\nHowever, you cannot convert a string that does not contain a valid representation of a number to an integer. For example, you cannot convert the string \"42.5\" to an integer.\n\nint('42.5')\n\nValueError: invalid literal for int() with base 10: '42.5'\n\n\nWhen converting to a boolean value, most values will be converted to True, except for 0, 0.0, and \"\", which will be converted to False.\n\nbool(0)\n\nFalse\n\n\n\nbool(1)\n\nTrue\n\n\n\nbool(\"\")\n\nFalse\n\n\n\nbool(\"33\")\n\nTrue\n\n\nThe None value is a special type in Python that represents the absence of a value. You can use the None value to initialize a variable without assigning it a value. For example, you can initialize a variable problem to None by running the following code.\n\nproblem = None\ntype(problem)\n\nNoneType"
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#comments",
    "href": "intro-to-python/python-basics/index.html#comments",
    "title": "Python Basics",
    "section": "Comments",
    "text": "Comments\nComments are an essential part of writing clear, maintainable code. They help explain the purpose, logic, or any specific details of the code that might not be obvious at first glance. However, excessive or unnecessary commenting can clutter your code and make it harder to read. To strike the right balance, consider the guidelines listed in Table¬†5 when deciding when to use comments and when to avoid them:\n\n\nTable¬†5: Guidelines for comments\n\n\n\n\n\n\nGuideline\nDescription\n\n\n\n\nUse comments when the code is complex or non-obvious\nWhen your code involves complex algorithms, calculations, or logic that may be difficult for others (or yourself) to understand at a glance, use comments to explain the reasoning behind the code or to provide additional context.\n\n\nAvoid comments for simple or self-explanatory code\nFor code that is simple, clear, and easy to understand, avoid adding comments. Instead, use descriptive variable and function names that convey the purpose of the code.\n\n\nUse comments to explain the ‚Äòwhy‚Äô, not the ‚Äòhow‚Äô\nGood comments explain the purpose of a piece of code or the reasoning behind a decision. Focus on providing context and insight that isn‚Äôt immediately apparent from reading the code. Avoid repeating what the code is doing, as this can be redundant and clutter the code.\n\n\nAvoid commenting out large blocks of code\nInstead of leaving large blocks of commented-out code in your final version, remove them. It‚Äôs better to use version control systems like Git to keep track of previous versions of your code.\n\n\nKeep comments up-to-date\nEnsure that your comments are always up-to-date with the code they describe. Outdated comments can be confusing and misleading, making it harder to understand the code.\n\n\nUse comments to provide additional information\nUse comments to provide references to external resources, such as links to relevant documentation, papers, or articles. This can be helpful for providing additional context or background information related to the code.\n\n\nUse consistent commenting style\nFollow a consistent commenting style throughout your codebase. This makes it easier for others to read and understand your comments.\n\n\n\n\n\nWriting comments\nIn Python, comments are created using the # symbol. Any text that follows the # symbol on the same line is ignored by the Python interpreter. Comments can be placed on a separate line or at the end of a line of code.:\n\n# This is a single-line comment\n\nprice = 150  # This is an inline comment\n\nYou can also create multi-line comments by enclosing the text in triple quotes (\"\"\" or '''). Multi-line comments are often used to provide docstrings (documentation strings) for functions and classes. We‚Äôll learn more about functions and classes in a later section. Note that multi-line comments are technically strings, but the Python interpreter ignores them and does not store them in memory because they are not assigned to a variable.\n\n\"\"\"\nThis is a multi-line comment.\nYou can write your comments across multiple lines.\n\"\"\"\n\n'\\nThis is a multi-line comment.\\nYou can write your comments across multiple lines.\\n'\n\n\nComments can occur alongside code to document its purpose or explain the logic.\n\n# Calculate compound interest\nprincipal = 1000  # Principal amount\nrate = 0.05  # Annual interest rate\ntime = 5  # Time in years\n\n# Future value with compound interest formula\nfuture_value = principal * (1 + rate) ** time\n\n# Display the result\nprint(f\"Future value: {future_value:.2f}\")\n\nFuture value: 1276.28\n\n\n\n\n\n\n\n\nDon‚Äôt overdo it\n\n\n\nComments are useful for providing additional context or explanation, but they can also be overdone. Avoid adding comments for trivial or self-explanatory code. For example, the code above is simple and clear enough to understand without comments, so adding comments is decreasing readability instead of improving it.\n\n\nComments are usually written in English, but you can use any language as long as the file is UTF-8 encoded. You can also use emojis in comments if you like üòä."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#numbers",
    "href": "intro-to-python/python-basics/index.html#numbers",
    "title": "Python Basics",
    "section": "Numbers",
    "text": "Numbers\nPython provides built-in functions and operators to perform mathematical operations on numbers. Some commonly used mathematical functions include abs(), round(), min(), max(), and pow(). Additionally, Python‚Äôs math library offers more advanced functions like trigonometry and logarithms.\n\n\n\n\n\n\nRounding errors\n\n\n\nFloating-point numbers may be subject to rounding errors due to the limitations of their binary representation. Keep this in mind when comparing or performing calculations with floats. Consider using the Decimal data type from Python‚Äôs decimal library to avoid floating-point inaccuracies when dealing with high-precision financial data.\n\n\n\n\n\n\n\n\nPerformance\n\n\n\nWhen working with large datasets or performing complex calculations, consider using third-party libraries like NumPy and pandas, which are covered in later chapters, for improved performance and additional functionality.\n\n\n\nOperations\nThe Python language supports many mathematical operations. Table¬†6 lists some of the most commonly used operators.\n\n\nTable¬†6: Basic Arithmetic Operations\n\n\nOperator\nName\nExample\nResult\n\n\n\n\n+\nAddition\n1 + 2\n3\n\n\n-\nSubtraction\n1 - 2\n-1\n\n\n*\nMultiplication\n3 * 4\n12\n\n\n/\nDivision\n1 / 2\n0.5\n\n\n**\nExponentiation\n2 ** 3\n8\n\n\n//\nFloor division\n14 // 3\n4\n\n\n%\nModulo (remainder)\n14 % 3\n2\n\n\n\n\n\na = 5\nb = 3\n\nprint(f\"Addition: a + b = {a + b}\")\nprint(f\"Subtraction: a - b = {a - b}\")\nprint(f\"Multiplication: a * b = {a * b}\")\nprint(f\"Division: a / b = {a / b}\")\nprint(f\"Exponentiation: a ** b = {a ** b}\")\nprint(f\"Floor Division: a // b = {a // b}\")\nprint(f\"Modulo: a % b = {a % b}\")\n\nAddition: a + b = 8\nSubtraction: a - b = 2\nMultiplication: a * b = 15\nDivision: a / b = 1.6666666666666667\nExponentiation: a ** b = 125\nFloor Division: a // b = 1\nModulo: a % b = 2\n\n\n\n\n\n\n\n\nf-strings\n\n\n\nThe previous examples use a special type of strings called f-strings to format the output. f-strings are a convenient way to embed variables and expressions inside strings. They are denoted by the f prefix and curly braces ({}) containing the variable or expression to be evaluated.\nWe cover f-strings in more details in Section¬†8.2.\n\n\n\n\nCommon mathematical functions\nTo round numbers, use the round() function. The round() function takes two arguments: the number to be rounded and the number of decimal places to round to. The number is rounded to the nearest integer if the second argument is omitted.\n\nrounded_num = round(5.67, 1)\n\nprint(rounded_num)\nprint(type(rounded_num))\n\n\nrounded_to_int = round(5.67)\n\nprint(rounded_to_int)\nprint(type(rounded_to_int))\n\n5.7\n&lt;class 'float'&gt;\n6\n&lt;class 'int'&gt;\n\n\nSome mathematical functions will require the use of the math module from the Python Standard Library. The standard library is a collection of modules included with every Python installation. You can use the functions and types in these modules by importing them into your code using the import statement.\nFor example, to calculate the square root of a number, you can use the sqrt() function from the math module:\n\n1import math\n\nmath.sqrt(25)\n\n\n1\n\nImports the math module, making its functions available in the current code.\n\n\n\n\n5.0\n\n\nThis is only one of the many functions in the math module. You can view the complete list of functions in the module documentation. The math module also contains constants like pi and e, which you can access using the dot notation.\n\nmath.pi\n\n3.141592653589793\n\n\n\n\nRandom numbers\nIt is often useful to generate random numbers for simulations and other applications. Python‚Äôs random module provides functions for generating pseudo-random1 numbers from different distributions.\n\n\n\n\n\n\nPseudo-random number generator\n\n\n\nThe random module uses the Mersenne Twister algorithm to generate pseudo-random numbers. This algorithm is deterministic, meaning that given the same seed value, it will produce the same sequence of numbers every time. This is useful for debugging and testing but not for security purposes. If you need a cryptographically secure random number generator, use the secrets module instead.\n\n\nThe random.seed() function initializes the pseudo-random number generator. If you do not call this function, Python will automatically call it the first time you generate a random number. The random.seed() function takes an optional argument that can be used to set the seed value. This can be useful for debugging and testing, allowing you to generate the same sequence of random numbers every time. If you do not specify a seed, Python will use the system time as the seed value, so you will get a different sequence of random numbers every time.\n\nimport random\n\n1random.seed(42)\n\n\n1\n\nSets the seed value to 42. Why 42? Because it‚Äôs the answer to life, the universe, and everything.\n\n\n\n\nrandom.random() generates a random float between 0 and 1 (exclusive).\n\nrand_num = random.random()\n\nrand_num\n\n0.6394267984578837\n\n\nrandom.randint(a, b) generates a random integer between a and b (inclusive).\n\nrand_int = random.randint(1, 10)\n\nrand_int\n\n1\n\n\nrandom.uniform(a, b) generates a random float between a and b (exclusive).\n\nrand_float = random.uniform(0, 1)\n\nrand_float\n\n0.7415504997598329\n\n\nrandom.normalvariate(mu, sigma) generates a random float from a normal distribution with mean mu and standard deviation sigma.\n\nrand_norm = random.normalvariate(0, 1)\n\nrand_norm\n\n-0.508616386057752\n\n\nThe full list of functions in the random module can be found in the module documentation.\n\n\nFloats and decimals\nBecause of the way computers store numbers, floating-point numbers are not exact. This can lead to unexpected results when performing arithmetic operations on floats.\n\n2.33 + 4.44\n\n6.7700000000000005\n\n\nTo avoid this problem when exact results are needed, use the Decimal type from the decimal module to perform arithmetic operations on decimal numbers. You could import the module using import decimal but this would require you to prefix all the functions and types in the module with decimal. To avoid this, you can directly import the Decimal type from the decimal module using from decimal import Decimal.\n\n1from decimal import Decimal\n\nDecimal(\"2.33\") + Decimal(\"4.44\")\n\n\n1\n\nImports the Decimal type from the decimal module. You can now refer to the Decimal type directly without having to prefix it with decimal.\n\n\n\n\nDecimal('6.77')\n\n\n\n\n\n\n\n\nDecimals vs.¬†floats\n\n\n\nUsing the Decimal type in Python provides precise decimal arithmetic and avoids rounding errors, making it suitable for financial and monetary calculations, while floats offer faster computation and are more memory-efficient but can introduce small inaccuracies due to limited precision and binary representation.\n\n\n\n\nFinancial formulas\nMany financial calculations involve performing arithmetic operations on financial data. Here are two examples of common calculations in finance and how they can be implemented in Python.\n\nCalculating the present value of a future cash flow\nThe formula for calculating the present value of a future cash flow is:  PV = \\frac{FV_t}{(1 + r)^t},  where FV_t is the future value of the cash flow at time t, r is the discount rate, and t is the number of periods.\n\nfuture_value = 1000\ndiscount_rate = 0.05\nperiods = 5\n\npresent_value = future_value / (1 + discount_rate) ** periods\n\npresent_value\n\n783.5261664684588\n\n\n\n\nCalculating the future value of an annuity\nThe formula for calculating the future value of an annuity is:  FV = PMT \\frac{(1 + r)^t - 1}{r},  where PMT is the payment, r is the interest rate, and t is the number of periods.\nIt can be written in Python as:\n\npayment = 100\nrate = 0.05\nperiods = 5\n\nfuture_value_annuity = payment * ((1 + rate) ** periods - 1) / rate\n\nfuture_value_annuity\n\n552.5631250000007\n\n\n\n\n\n\n\n\nParentheses and operator precedence\n\n\n\nPython, just like mathematics, follows a specific order of operations when evaluating expressions. The complete list of precedence rules can be found in the Python documentation.\nWhen in doubt, use parentheses to make the order of operations explicit.\nFor arithmetic operations, the order of operations is as follows:\n\nExponents\nNegative (-)\nMultiplication and division\nAddition and subtraction"
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#sec-defining-functions",
    "href": "intro-to-python/python-basics/index.html#sec-defining-functions",
    "title": "Python Basics",
    "section": "Defining functions",
    "text": "Defining functions\nFunctions are blocks of organized and reusable code that perform a specific action. They allow you to encapsulate a set of instructions, making your code modular and easier to maintain. Functions can take input parameters, perform operations on those inputs, and return a result.\nDefining a function in Python involves the following steps:\n\nUse the def keyword: Start by using the def keyword, followed by the function name and parentheses that enclose any input parameters.\nAdd input parameters: Specify any input parameters within the parentheses, separated by commas. These parameters allow you to pass values to the function, which it can then use in its calculations or operations.\nWrite the function body: After the parentheses, add a colon (:) and indent the following lines to create the function body. This block of code contains the instructions that the function will execute when called.\nReturn a result (optional): If your function produces a result, use the return statement to send the result back to the caller. If no return statement is specified, the function will return None by default.\n\n\n\n\n\n\n\nBest practices\n\n\n\nWhen defining functions, keep the following best practices in mind:\n\nChoose descriptive function names: Use meaningful names that reflect the purpose of the function, making your code more readable and easier to understand.\nKeep functions small and focused: Each function should have a single responsibility, making it easier to test, debug, and maintain.\n\n\n\nWe can define functions to perform a wide variety of tasks. For example, we can define a function to calculate the present value of a future cash flow:\n\n1def present_value(future_value, discount_rate, periods):\n2    return future_value / (1 + discount_rate) ** periods\n\n\n# Example usage:\nfuture_value = 1000\ndiscount_rate = 0.05\nperiods = 5\n3result = present_value(future_value, discount_rate, periods)\nprint(f\"Present value: {result:.2f}\")\n\n\n1\n\nDefines a function called present_value that takes three input parameters: future_value, discount_rate, and periods.\n\n2\n\nCalculates the present value of a future cash flow using the formula from the previous section and returns the result to the caller. The code in the function body is indented to indicate that it is part of the function.\n\n3\n\nCalls the present_value function with the specified input values and stores the returned value in a variable called result. When the function is called, the input values are passed to the function as arguments in the same order as the parameters were defined. The function body is then executed, and the result is returned to the caller.\n\n\n\n\nPresent value: 783.53\n\n\n\n\n\n\n\n\nIndentation\n\n\n\nIndentation refers to the spaces or tabs used at the beginning of a line to organize code. It helps Python understand the program‚Äôs structure and which lines of code are grouped together.\nThe Python language specification mandates the use of consistent indentation for code readability and proper execution. Indentation is typically achieved using four spaces per level. It plays a crucial role in determining the scope and hierarchy of statements within control structures, such as loops and conditional statements. For example, the statements that are part of a function body must be indented to indicate that they are part of the function. The Python interpreter knows that the function body ends when the indentation level returns to the previous level.\n\n\nWe will learn more about functions in Section¬†12."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#sec-strings",
    "href": "intro-to-python/python-basics/index.html#sec-strings",
    "title": "Python Basics",
    "section": "Strings",
    "text": "Strings\nText data is often encountered in finance in the form of stock symbols, company names, descriptions, or financial reports. Understanding how to work with strings is essential for processing and manipulating text data effectively.\nStrings are sequences of characters, and they can be created using single quotes (' '), double quotes (\" \"), or triple quotes (''' ''' or \"\"\" \"\"\") for multi-line strings.\n\n\n\n\n\n\nSpecial characters\n\n\n\nSome characters have special meanings in Python strings. The backslash (\\) is used to escape characters that have special meaning, such as newline (\\n) or tab (\\t). To include a backslash in a string, you need to escape it by adding another backslash before it (\\\\). Alternatively, you can use raw strings by prefixing the strings with r or R, which will treat backslashes as literal characters. For example, these two strings are equivalent:\nstr1 = \"C:\\\\Users\\\\John\"\nstr2 = r\"C:\\Users\\John\"\n\n\n\nString operations\nThe Python language provides many common string operations. Table¬†7 lists some of the most commonly used operations.\n\n\nTable¬†7: Common string operations\n\n\n\n\n\n\n\nOperation\nExample\nDescription\n\n\n\n\nConcatenate strings\nresult = str1 + \" \" + str2\nCombines two or more strings together\n\n\nRepeat strings\nresult = repeat_str * 3\nRepeats a string a specified number of times\n\n\nLength of a string\nlength = len(text)\nGets the length (number of characters) of a string\n\n\nAccess characters in a string\nfirst_char = text[0]\nRetrieves a specific character in a string\n\n\nSlice a string\nslice_text = text[0:12]\nExtracts a part of a string\n\n\nConvert case\nupper_text = text.upper()\nConverts a string to uppercase\n\n\n\nlower_text = text.lower()\nConverts a string to lowercase\n\n\nJoin a list of strings\ntext = \", \".join(companies)\nJoins a list of strings using a delimiter\n\n\nSplit a string\ncompanies = text.split(\", \")\nSplits a string into a list based on a delimiter\n\n\nReplace a substring\nnew_text = text.replace(\"Finance\", \"Python\")\nReplaces a specified substring in a string\n\n\nCheck substring existence\nresult = substring in text\nChecks if a substring exists in a string\n\n\n\n\nWe can concatenate (combine) two or more strings into a single string using the + operator.\n\nstr1 = \"Hello\"\nstr2 = \"World\"\nresult = str1 + \" \" + str2\nprint(result)\n\nHello World\n\n\nThe * operator repeats a string multiple times.\n\nrepeat_str = \"Python \"\nresult = repeat_str * 3\nprint(result)\n\nPython Python Python \n\n\nThe len() function returns the string‚Äôs length (number of characters).\n\ntext = \"Finance\"\nlength = len(text)\nprint(length)\n\n7\n\n\nSingle characters in a string can be accessed using the index of the character within square brackets ([]). Python uses zero-based indexing, so the first character in a string has index 0, the second character has index 1, and so on. You can also use negative indices to access characters from the end of a string, with the last character having index -1, the second last character having index -2, and so on.\n\ntext = \"Python\"\nfirst_char = text[0]\nlast_char = text[-1]\nprint(first_char)\nprint(last_char)\n\nP\nn\n\n\nExtracting a portion of a string by specifying a start and end index is called slicing. In Python, you can slice a string using the following syntax: text[start:end]. The start index is inclusive, while the end index is exclusive. If the start index is omitted, it defaults to 0. If the end index is omitted, it defaults to the length of the string.\n\ntext = \"empirical finance Python\"\nslice_text = text[0:7]\nprint(slice_text)\n\nempiric\n\n\nThe upper() and lower() methods convert a string to uppercase or lowercase, respectively.\n\ntext = \"Finance\"\nupper_text = text.upper()\nlower_text = text.lower()\nprint(upper_text)\nprint(lower_text)\n\nFINANCE\nfinance\n\n\n\n\n\n\n\n\nMethods vs functions\n\n\n\nA method is similar to a function but associated with a specific object or data type. In this case, upper() and lower() are methods specific to the str (string) data type. When we call the upper method on the text object using the dot notation (text.upper()), Python knows to transform the string stored in the text variable. Methods are particularly useful because they allow us to perform actions or operations specific to the object or data type they belong to, and they improve code readability by making it clear what object the method is being called on.\n\n\nThe join() method joins a list of strings into a single string using a delimiter. The delimiter can be specified as an argument to the join() method. Lists are introduced in the next section.\n\ncompanies = [\"Apple\", \"Microsoft\", \"Google\"]\ntext = \" | \".join(companies)\nprint(text)\n\nApple | Microsoft | Google\n\n\nThe split() method splits a string into a list of substrings based on a delimiter. The delimiter can be specified as an argument to the split() method. If no delimiter is specified, the string is split on whitespace characters.\n\ntext = \"Apple, Microsoft, Google\"\ncompanies = text.split(\", \")\nprint(companies)\n\n['Apple', 'Microsoft', 'Google']\n\n\nThe replace() method replaces a substring in a string with another string. It takes two arguments: the substring to replace and the string to replace it with.\n\ntext = \"Introduction to Finance\"\nnew_text = text.replace(\"Finance\", \"Python\")\nprint(new_text)\n\nIntroduction to Python\n\n\nThe in operator checks if a substring exists in a string. It returns a boolean value, True if the substring exists in the string, and False otherwise.\n\ntext = \"Introduction to Python\"\nsubstring = \"Python\"\nresult = substring in text\nprint(result)\n\nTrue\n\n\nThe Python documentation provides a complete list of string methods that you can refer to for more details.\n\n\nFormatting strings\nYou will often encounter situations where you must present or display data in a formatted, human-readable manner. F-strings are a powerful tool for formatting strings and embedding expressions or variables directly within the string. They provide a concise and easy-to-read way of formatting strings, making them an essential tool for working with text data.\nF-strings, also known as ‚Äúformatted string literals,‚Äù allow you to embed expressions, variables, or even basic arithmetic directly into a string by enclosing them in curly braces {} within the string. The expressions inside the curly braces are evaluated at runtime and then formatted according to the specified format options.\nSome key features of f-strings that are useful include:\n\nExpression Evaluation: You can embed any valid Python expression within the curly braces, including variables, arithmetic operations, or function calls. This feature enables you to generate formatted strings based on your data dynamically.\nFormatting Options: F-strings support various formatting options, such as alignment, width, precision, and thousand separators. These options can be specified within the curly braces after the expression, separated by a colon (:).\nFormat Specifiers: You can use format specifiers to control the display of numbers, such as specifying the number of decimal places, using scientific notation, or adding a percentage sign. Format specifiers are especially useful in finance when working with currency, percentages, or large numbers.\n\nTo create an f-string, prefix the string with an f character, followed by single or double quotes. You can then embed expressions or variables within the string by enclosing them in curly braces ({}). For example, this lets you concatenate strings and variables together in a single statement:\n\nticker = \"AAPL\"\nexchange = \"NASDAQ\"\ncompany_name = \"Apple, Inc.\"\nfull_name = f\"{company_name} ({exchange}:{ticker})\"\nprint(full_name)\n\nApple, Inc. (NASDAQ:AAPL)\n\n\nPython will convert the expression within the curly braces to a string, which can be used to convert numbers to strings.\n\nnum = 42\nnum_str = f\"{num}\"\nprint(num_str)\n\n42\n\n\nPython evaluates the expression within the curly braces at runtime and then formats the string according to the specified format options. For example, you can use the :,.2f format option to display a number with a thousand separator and two decimal places.\n\namount = 12345.6789\nformatted_amount = f\"${amount:,.2f}\"\nprint(formatted_amount) \n\n$12,345.68\n\n\nYou can also use the :.2% format option to display a number as a percentage with two decimal places.\n\nrate = 0.05\nformatted_rate = f\"{rate:.2%}\"\nprint(formatted_rate) \n\n5.00%\n\n\nThe datetime module provides a datetime class to represent dates and times. The datetime class has a now() method that returns the current date and time. You can use the :%Y-%m-%d format option to display the date in YYYY-MM-DD format.\n\nfrom datetime import datetime\n\ncurrent_date = datetime.now()\nformatted_date = f\"{current_date:%Y-%m-%d}\"\nprint(formatted_date)\n\n2024-01-21\n\n\nYou can also use f-strings to align text to the left (&lt;), right (&gt;), or center (^) within a fixed-width column:\n\nticker = \"AAPL\"\nprice = 150.25\nchange = -1.25\n\n1formatted_string = f\"|{ticker:&lt;10}|{price:^10.2f}|{change:&gt;10.2f}|\"\nprint(formatted_string)\n\n\n1\n\nThe :&lt;10 format option aligns the text to the left within a 10-character column. The :^10.2f format option aligns the number to the center within a 10-character column and displays it with two decimal places. The :&gt;10.2f format option aligns the number to the right within a 10-character column and displays it with two decimal places.\n\n\n\n\n|AAPL      |  150.25  |     -1.25|\n\n\nMultiline f-strings work the same way as multiline strings, except that they are prefixed with an f character. You can use multiline f-strings to create formatted strings that span multiple lines.\n\nstock = \"AAPL\"\nprice = 150.25\nchange = -1.25\n\nformatted_string = f\"\"\"\nStock:  \\t{stock}\nPrice:  \\t${price:.2f}\nChange: \\t${change:.2f}\n\"\"\"\nprint(formatted_string)\n\n\nStock:      AAPL\nPrice:      $150.25\nChange:     $-1.25\n\n\n\n\n\n\n\n\n\nAlternative formatting methods\n\n\n\nWhen reading code or answers on websites such as Stack Overflow or receiving suggestions from AI-assisted coding assistant, you may encounter other string formatting methods. Before f-strings, the two primary string formatting methods in Python were %-formatting and str.format().\n%-formatting\nAlso known as printf-style formatting, %-formatting uses the % operator to replace placeholders with values. Inspired by the printf function in C, it has been available since early versions of Python. It is less readable and more error-prone than other methods.\nExample:\nformatted_string = \"%s has a balance of $%.2f\" % (name, balance)\nstr.format()\nThe str.format() method embeds placeholders using curly braces {} and replaces them with the format() method. Introduced in Python 2.6, it offers improved readability and more advanced formatting options compared to %-formatting.\nExample:\nformatted_string = \"{} has a balance of ${:,.2f}\".format(name, balance)\nAdvantages of f-strings\nI recommend using f-strings instead of %-formatting or str.format() for string formatting for the following reasons:\n\nReadability: Concise syntax with expressions and variables embedded directly.\nFlexibility: Supports any valid Python expression within curly braces.\nPerformance: Faster than other methods, evaluated at runtime.\nSimplicity: No need to specify variable order or maintain separate lists."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#sec-collections",
    "href": "intro-to-python/python-basics/index.html#sec-collections",
    "title": "Python Basics",
    "section": "Collections",
    "text": "Collections\nSequences and collections are fundamental data structures in Python that allow you to store and manipulate multiple elements in an organized manner. They differ along three dimensions: order, mutability, and indexability. An ordered collection is one where the elements are stored in a particular order, the order of the elements is important, and you can iterate over the elements in that order. A collection is mutable if you can add, remove, or modify elements, after it is created. A collection is indexable if you can refer to its elements by their index (position or key).\nTable¬†8 presents the main types of sequences and collections in Python. You are already familiar with the string type, an ordered, immutable, and indexable sequence of characters.\n\n\nTable¬†8: Sequences and collections in Python\n\n\n\n\n\n\n\n\nName\nType\nDescription\nExample\n\n\n\n\nList\nlist\nOrdered, mutable, and indexed. Allows duplicate members.\n[1, 2, 3]\n\n\nTuple\ntuple\nOrdered, immutable, and indexed. Allows duplicate members.\n(1, 2, 3)\n\n\nSet\nset\nUnordered, mutable, and unindexed. No duplicate members.\n{1, 2, 3}\n\n\nDictionary\ndict\nUnordered, mutable, and indexed. No duplicate index entries. Elements are indexed according to a key.\n{\"a\": 1, \"b\": 4}\n\n\nString\nstring\nOrdered, immutable, and indexed. Allows duplicate characters.\n\"abc\"\n\n\n\n\n\nLists\nLists in Python are ordered collections of items that can hold different data types. They are mutable, meaning that elements can be added, removed, or modified. Lists are versatile and commonly used to store and manipulate sets of related data. The elements within a list are accessed using indexes, which allow for easy retrieval and modification. Lists also support various built-in methods and operations for efficient data manipulation, such as appending, extending, sorting, and slicing.\nA list is created by enclosing a comma-separated sequence of elements within square brackets ([ ]). The elements can be of any data type, including other lists. The following code snippet creates a list of strings and a list of integers.\n\nstocks = [\"AAPL\", \"GOOG\", \"MSFT\"]\nprices = [150.25, 1200.50, 250.00]\n\nYou can access the elements of a list using their index. The index of the first element is 0, the index of the second element is 1, and so on. You can also use negative indexes to access elements from the end of the list. The index of the last element is -1, the index of the second to last element is -2, and so on. The following code snippet illustrates how to access the elements of the stocks and prices lists.\n\nfirst_stock = stocks[0]\nprint(first_stock)\n\nlast_price = prices[-1]\nprint(last_price)\n\nAAPL\n250.0\n\n\nYou can replace the elements of a list by assigning new values to their indexes, add new elements to the list using the append() method, or delete elements from the list using the remove() method.\n\n# Replace an element\nstocks[1] = \"GOOGL\"\nprint(stocks)\n\n# Adding an element to the list\nstocks.append(\"AMZN\")\nprint(stocks)\n\n# Removing an element from the list\nstocks.remove(\"MSFT\")\nprint(stocks)\n\n['AAPL', 'GOOGL', 'MSFT']\n['AAPL', 'GOOGL', 'MSFT', 'AMZN']\n['AAPL', 'GOOGL', 'AMZN']\n\n\nYou can also use the len() function to get the length of a list, and the in operator to check if an element is present in a list.\n\n# Length of the list\nlist_length = len(stocks)\nprint(f\"Length: {list_length}\")\n\n# Checking if an element is in the list\nis_present = \"AAPL\" in stocks\nprint(f\"Is AAPL in the list? {is_present}\")\n\nLength: 3\nIs AAPL in the list? True\n\n\n\n\nTuples\nTuples are ordered collections of elements that are immutable, meaning they cannot be modified after creation. They are typically used to store related pieces of data as a single entity, and their immutability provides benefits such as ensuring data integrity and enabling safe data sharing across different parts of a program.\n\n\n\n\n\n\nTuples vs lists\n\n\n\nTuples and lists in Python differ in mutability, syntax, and use cases. Tuples are commonly used for fixed data, have a slight performance advantage over lists and can be more memory-efficient. Lists are commonly used for variable data, and provide more flexibility in terms of operations and methods.\n\n\nA tuple is created by enclosing a comma-separated sequence of elements within parentheses (( )). The elements can be of any data type, including other tuples. The following code snippet creates a tuple of integers and a tuple of strings.\n\nmu = 0.1\nsigma = 0.2\ntheta = 0.5\n\nparameters = (mu, sigma, theta)\nprint(parameters)\n\n(0.1, 0.2, 0.5)\n\n\nYou can access the elements of a tuple using their index, find their length using len(), just like with lists.\n\n# Accessing elements in a tuple\nsigma0 = parameters[1]\nprint(sigma0)\n\n# Length of the tuple\ntuple_length = len(parameters)\nprint(f\"Length: {tuple_length}\")\n\n0.2\nLength: 3\n\n\nTuples are immutable, so you cannot add, remove, or replace their elements directly. You can, however, create a new tuple with the modified elements. Also note that you can modify mutable elements within a tuple, such as a list.\n\na = [1, 2, 3]\nb = (\"c\", a, 2)\nprint(f\"Before appending to list a: {b}\")\n\na.append(4)\nprint(f\"After appending to list a: {b}\")\n\nBefore appending to list a: ('c', [1, 2, 3], 2)\nAfter appending to list a: ('c', [1, 2, 3, 4], 2)\n\n\nb still contains the same elements, but the list a within the tuple has been modified.\n\nTuple unpacking\nTuple unpacking is a powerful feature of Python that allows you to assign multiple variables from the elements of a tuple in a single line of code. It is a form of ‚Äúdestructuring assignment‚Äù that provides a concise way to extract the elements of a tuple into individual variables.\nTo perform tuple unpacking, you use a sequence of variables on the left side of an assignment statement, followed by a tuple on the right side. When the assignment is made, each variable on the left side will be assigned the corresponding value from the tuple on the right side.\nHere is an example:\n\n# Create a tuple\nt = (1, 2, 3)\n\n# Unpack the tuple into three variables\na, b, c = t\n\n# Display the values of the variables\nprint(f\"a: {a}, b: {b}, c: {c}\")\n\na: 1, b: 2, c: 3\n\n\nIn this example, the tuple t contains three elements: 1, 2, and 3. When the tuple is unpacked into the variables a, b, and c, each variable gets assigned the corresponding value from the tuple: a gets 1, b gets 2, and c gets 3.\nTuple unpacking can be useful in various situations. For example, when working with functions that return multiple values as a tuple, you can use tuple unpacking to assign the return values to individual variables. Here‚Äôs an example:\n\n# Define a function that returns a tuple\ndef get_top3_stocks():\n    return (\"AAPL\", \"MSFT\", \"AMZN\")\n\n# Unpack the returned tuple into three variables\nstock1, stock2, stock3 = get_top3_stocks()\n\n# Display the values of the variables\nprint(f\"Largest: {stock1}, 1nd: {stock2}, 3rd: {stock3}\")\n\nLargest: AAPL, 1nd: MSFT, 3rd: AMZN\n\n\nNote that the number of variables on the left side of the assignment must match the number of elements in the tuple being unpacked.\n\n\n\nSets\nSets are unordered collections of unique elements. They are defined using curly braces { } or the set() constructor. Sets do not allow duplicate values and support various operations such as intersection, union, and difference. Sets are commonly used for tasks like removing duplicates from a list, membership testing, and mathematical operations on distinct elements.\n\n# Creating a set\nunique_numbers = {1, 2, 3, 2, 1}\nprint(unique_numbers)\n\n# Adding an element to the set\nunique_numbers.add(4)\nprint(f\"Added 4: {unique_numbers}\")\n\n# Removing an element from the set\nunique_numbers.remove(1)\nprint(f\"Removed 1: {unique_numbers}\")\n\n# Checking if an element is in the set\nis_present = 2 in unique_numbers\nprint(f\"Is 2 in the set? {is_present}\")\n\n# Length of the set\nset_length = len(unique_numbers)\nprint(f\"Length: {set_length}\")\n\n{1, 2, 3}\nAdded 4: {1, 2, 3, 4}\nRemoved 1: {2, 3, 4}\nIs 2 in the set? True\nLength: 3\n\n\nSets support operations such as intersection, union, and difference, which are performed using the &, |, and - operators respectively.\n\nset1 = {1, 2, 3, 4}\nset2 = set([3, 4, 5, 6])\n\n# Intersection\nprint(f\"Intersection: {set1 & set2}\")\n\n# Union\nprint(f\"Union: {set1 | set2}\")\n\n# Difference\nprint(f\"Difference: {set1 - set2}\")\n\nIntersection: {3, 4}\nUnion: {1, 2, 3, 4, 5, 6}\nDifference: {1, 2}\n\n\n\n\n\n\n\n\nSets and data types\n\n\n\nSets can contain elements of different data types, including numbers, strings, and tuples. However, sets only support immutable elements, so you cannot add lists or dictionaries to a set.\n\n\n\n\nDictionaries\nDictionaries are key-value pairs that provide a way to store and retrieve data using unique keys. They are defined with curly braces { } like sets, but contain pairs of elements called items, where each item is a key-value pair separated by a colon (:).\nDictionaries are unordered and mutable, allowing for efficient data lookup and modification. They are commonly used for mapping and associating values with specific keys, making them useful for tasks like storing settings, organizing data, or building lookup tables.\n\nstock_prices = {\"AAPL\": 150.25, \"GOOGL\": 1200.50, \"MSFT\": 250.00}\nprint(stock_prices)\n\n{'AAPL': 150.25, 'GOOGL': 1200.5, 'MSFT': 250.0}\n\n\nYou access the value for a specific key using square brackets [ ], and modify the value for a key using the assignment operator =. You add new key-value pairs to a dictionary using a new key and assignment operator and remove a key-value pair using the del keyword. The len() function returns the number of key-value pairs in a dictionary.\n\n# Accessing elements in a dictionary\nprice_aapl = stock_prices[\"AAPL\"]\nprint(f\"Price for AAPL: {price_aapl:0.2f}\")\n\n# Modifying an element\nstock_prices[\"GOOGL\"] = 1205.00\nprint(f\"Modified GOOGL: {stock_prices}\")\n\n# Adding a new element to the dictionary\nstock_prices[\"AMZN\"] = 3300.00\nprint(f\"Added AMZN: {stock_prices}\")\n\n# Removing an element from the dictionary\ndel stock_prices[\"MSFT\"]\nprint(f\"Removed MSFT: {stock_prices}\")\n\n# Length of the dictionary\ndict_length = len(stock_prices)\nprint(f\"Length: {dict_length}\")\n\nPrice for AAPL: 150.25\nModified GOOGL: {'AAPL': 150.25, 'GOOGL': 1205.0, 'MSFT': 250.0}\nAdded AMZN: {'AAPL': 150.25, 'GOOGL': 1205.0, 'MSFT': 250.0, 'AMZN': 3300.0}\nRemoved MSFT: {'AAPL': 150.25, 'GOOGL': 1205.0, 'AMZN': 3300.0}\nLength: 3\n\n\nThe collection module from Python‚Äôs standard library provides many other data structures such as defaultdict, OrderedDict, Counter, and deque. You can learn more about these data structures in the Python documentation."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#comparison-operators-and-branching",
    "href": "intro-to-python/python-basics/index.html#comparison-operators-and-branching",
    "title": "Python Basics",
    "section": "Comparison operators and branching",
    "text": "Comparison operators and branching\n\nComparison operators\nPython provides several comparison operators that allow you to compare values and evaluate expressions. Comparison operators can be used with various data types, such as numbers, strings, or even complex data structures, and return a boolean value (True or False). Table¬†9 lists the comparison operators available in Python.\n\n\nTable¬†9: Comparison operators in Python\n\n\nOperator\nName\nExample\nResult\n\n\n\n\n==\nEqual\n1 == 2\nFalse\n\n\n!=\nNot equal\n1 != 2\nTrue\n\n\n&gt;\nGreater than\n1 &gt; 2\nFalse\n\n\n&lt;\nLess than\n1 &lt; 2\nTrue\n\n\n&gt;=\nGreater or equal\n1 &gt;= 2\nFalse\n\n\n&lt;=\nLess or equal\n1 &lt;= 2\nTrue\n\n\nin\nMembership\n1 in [1, 2, 3]\nTrue\n\n\nis\nIdentity comparison\n1 is None\nFalse\n\n\n\n\nTo create more complex conditions, you can chain multiple comparisons in a single expression using logical operators like and, or, or not. The result of a logical operator is a boolean value (True or False). Table¬†10 lists the logical operators available in Python.\n\n\nTable¬†10: Logical operators in Python\n\n\na\nb\na and b\na or b\nnot a\n\n\n\n\nTrue\nTrue\nTrue\nTrue\nFalse\n\n\nTrue\nFalse\nFalse\nTrue\nFalse\n\n\nFalse\nTrue\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n\n\n\n\n\n\n\n\n& and | are bitwise operators, not logical operators\n\n\n\nPython also provides bitwise operators that perform bitwise operations on integers. These operators are & (bitwise AND), | (bitwise OR), ^ (bitwise XOR), ~ (bitwise NOT), &lt;&lt; (bitwise left shift), and &gt;&gt; (bitwise right shift). Most casual Python users will not need to use these operators, but they can be confusing for new users due to their similar syntax to logical operators in other programming languages. To add to the confusion, popular Python libraries like NumPy and Pandas overload the bitwise operators to perform logical operations on arrays.\nIt is crucial for beginners to understand the distinction between logical and bitwise operators and to use the appropriate operators (which are usually and, or, or not) based on their intended purpose to ensure the desired logical evaluations are achieved.\n\n\nLonger expressions can be grouped using parentheses to ensure the desired order of operations. For example, a and b or c is equivalent to (a and b) or c, whereas a and (b or c) is different. Python does not offer a built-in exclusive or (XOR) operator, but it can be achieved using a combination of other operators.\n\ndef xor(a, b):\n    return (a and not b) or (not a and b)\n\n\nprint(f\"xor(True, True)) = {xor(True, True)}\")\nprint(f\"xor(True, False)) = {xor(True, False)}\")\nprint(f\"xor(False, True)) = {xor(False, True)}\")\nprint(f\"xor(False, False)) = {xor(False, False)}\")\n\nxor(True, True)) = False\nxor(True, False)) = True\nxor(False, True)) = True\nxor(False, False)) = False\n\n\n\n\nBranching\nBranching allows your code to execute different actions based on specific conditions. The primary branching construct in Python is the if statement, which can be combined with elif (short for ‚Äúelse if‚Äù) and else clauses to create more complex decision-making structures.\nLike other compound statements in Python, the if statement uses indentation to group statements together. The general syntax for an if statement is to start with the if keyword followed by a condition, then a colon (:), and, finally, an indented block of code that will be executed if the condition evaluates to True. The elif and else clauses are optional and can be used to specify additional conditions and code blocks to execute if the initial condition evaluates to False. The elif clause is used to chain multiple conditions together, whereas the else clause is used to specify a default code block to execute if none of the previous conditions evaluate to True.\n\nprice = 150\n\nif price &gt; 100:\n    print(\"The stock price is high.\")\n\nThe stock price is high.\n\n\nIn the previous example, the code block is executed because the price = 150, therefore the condition price &gt; 100 evaluates to True.\nWe can add an else clause to specify a default code block to execute if the condition evaluates to False.\n\nprice = 50\n\nif price &gt; 100:\n    print(\"The stock price is high.\")\nelse:\n    print(\"The stock price is low.\")\n\nThe stock price is low.\n\n\nWe can add an elif clause to specify additional conditions to evaluate if the initial condition evaluates to False. The elif clause can be used multiple times to chain multiple conditions together. The elif clause is optional, but if it is used, it must come before the else clause. The else clause is also optional, but if it is used, it must come last.\nIn all cases, the code block associated with the first condition that evaluates to True will be executed, and the remaining conditions will be skipped. If none of the conditions evaluate to True, then the code block associated with the else clause will be executed. If there is no else clause, then nothing will be executed.\n\nprice = 75\n\nif price &gt; 100:\n    print(\"The stock price is high.\")\nelif price &gt; 50:\n    print(\"The stock price is moderate.\")\nelse:\n    print(\"The stock price is low.\")\n\nThe stock price is moderate.\n\n\nYou can nest if statements inside other if statements to create more complex branching structures. The code block associated with the nested if statement must be indented further than the outer if statement. The nested if statement will only be evaluated if the condition associated with the outer if statement evaluates to True. When reading nested if statements, it is helpful to read from the top down and to keep track of the indentation level to understand which code blocks are associated with which conditions.\n\nprice = 150\nvolume = 1000000\n\nif price &gt; 100:\n    if volume &gt; 500000:\n        print(\"The stock price is high and has high volume.\")\n    else:\n        print(\"The stock price is high but has low volume.\")\nelse:\n    print(\"The stock price is not high.\")\n\nThe stock price is high and has high volume.\n\n\nConditions can be combined using the logical operators and, or, and not to create more complex conditions.\n\nprice = 150\nvolume = 1000000\n\nif price &gt; 100 and volume &gt; 500000:\n    print(\"The stock price is high and has high volume.\")\nelif price &gt; 100 or volume &gt; 500000:\n    print(\"The stock price is high or has high volume.\")\nelse:\n    print(\"The stock price is not high and has low volume.\")\n\nThe stock price is high and has high volume.\n\n\n\n\nConditional assignment\nPython provides a convenient shorthand for assigning a value to a variable based on a condition. This is known as conditional assignment. The syntax for conditional assignment is variable = value1 if condition else value2. If the condition evaluates to True, the variable is assigned value1; otherwise, it is assigned value2.\n\nprice = 150\n\nmessage = \"The stock price is high.\" if price &gt; 100 else \"The stock price is low.\"\nprint(message)\n\nThe stock price is high."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#typing",
    "href": "intro-to-python/python-basics/index.html#typing",
    "title": "Python Basics",
    "section": "Typing",
    "text": "Typing\nPython is a dynamically typed language. This means that you don‚Äôt have to specify the type of a variable when you define it. The Python interpreter will automatically infer the type based on the value assigned to the variable.\nPython also supports optional type annotations, also called type hints, since version 3.5. This allows you to specify the types of variables, function arguments, and return values to improve code readability and catch potential errors early. The Python interpreter will ignore the type annotations and run the code normally. However, you can use external tools like mypy to analyze the code and check for type errors, and modern IDEs like VS Code provide built-in support for type checking.\n\nticker: str = \"AAPL\"\n\n\nstock_prices: list[float] = [150.25, 1200.50, 250.00]\n\n\n# Old version, not needed since Python 3.9\n\nfrom typing import List\n\nstock_prices: List[float] = [150.25, 1200.50, 250.00]\n\n\n# You can also specify function parameters and return types:\n\n\ndef calculate_profit(revenue: float, expenses: float) -&gt; float:\n    return revenue - expenses\n\n\nrevenue = 1000.00\nexpenses = 500.00\nprofit = calculate_profit(revenue, expenses)\n\n\n\n\n\n\n\nType hints in Visual Studio Code\n\n\n\nType hints are not required to run Python code, but they can be very useful to improve code readability and catch potential errors early. Modern IDEs like VS Code provide built-in support for type checking that you can enable.\nI find this quite overwhelming, so I prefer to enable type-checking only when needed. However, VS Code still uses type hints to provide useful features like hover info.\n\n\n\nTooltip when hovering over variable.\n\n\n\n\n\nTooltip when hovering over function.\n\n\n\n\nThe typing module provides a set of special types that can be used in type hints. Here are some of the most commonly used ones:\n\nAny: Any type\nOptional: An optional value (can be None)\nCallable: A function\nIterable: An iterable object (e.g., list, tuple, set)"
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#sec-functions-parameters-return-values",
    "href": "intro-to-python/python-basics/index.html#sec-functions-parameters-return-values",
    "title": "Python Basics",
    "section": "Functions: parameters and return values",
    "text": "Functions: parameters and return values\nFunctions help you organize and structure your code by encapsulating specific tasks or calculations. They allow you to define input parameters, perform operations, and return the results, making your code more flexible and maintainable. We have already written simple functions in Section¬†7; we will now look in more detail at how to define parameters and return values.\n\n\n\n\n\n\nType hints in examples\n\n\n\nIn the examples below, I use type hints to indicate the type of the function parameters and return values. Type hints are not required to run Python code, but using them is a good practice as they provide helpful information to other developers (including your future self!) and tools such as linters and type checkers.\n\n\n\nParameters\nParameters are variables defined within the function signature, enabling you to pass input values to the function when it is called. Parameters can have a default value assigned to them when no value is provided during the function call. Default values can make your functions more flexible and easy to use. Using the *args and **kwargs syntax, you can pass a variable number of positional or keyword arguments to a function, providing greater flexibility for handling different input scenarios.2\n\n\n\n\n\n\nParameter vs.¬†argument\n\n\n\nThe terms function parameter and argument refer to different concepts related to functions.\nFunction parameter: A function parameter is a variable defined in the function‚Äôs definition or signature. It represents a value that the function expects to receive when it is called. Parameters act as placeholders for the actual values that will be passed as arguments when the function is invoked.\nArgument: An argument is the actual value that is passed to a function when it is called. It corresponds to a specific function parameter and provides the actual data or input that the function operates on. Arguments are supplied in the function call, within parentheses, and are passed to the corresponding function parameters based on their position or using keyword arguments.\n\n\n\ndef calculate_roi(investment: float, profit: float) -&gt; float:\n    return (profit / investment) * 100.0\n\n\ninvestment = 2000.00\nprofit = 500.00\nroi = calculate_roi(investment, profit)\nprint(roi)\n\n25.0\n\n\nIn the previous example, variables investment and profit are passed to the function calculate_roi() in the same order as they are defined in the function definition. This is called positional arguments. The names of the variables do not matter, only the order in which they are passed to the function. If we invert the order of the variables, the result will be different.\n\nbad_roi = calculate_roi(profit, investment)\nprint(bad_roi)\n\n400.0\n\n\nPositional arguments can be confusing when the function has many parameters or when the order of the arguments is not obvious. To avoid this, you can use keyword arguments.\n\nroi1 = calculate_roi(investment=2000.00, profit=500.00)\nprint(roi1)\n\nroi2 = calculate_roi(profit=500.00, investment=2000.00)\nprint(roi2)\n\nroi3 = calculate_roi(profit=profit, investment=investment)\nprint(roi3)\n\n25.0\n25.0\n25.0\n\n\nNote that the name of the original variables does not matter, only the name of the parameters in the function definition. In the last example, we use the same names for the variables and the parameters, but the Python interpreter does not care about that. The following code is equivalent to the previous one:\n\nx = 2000.00\ny = 500.00\n\nroi4 = calculate_roi(profit=y, investment=x)\nprint(roi4)\n\n25.0\n\n\nYou can also mix positional and keyword arguments. However, positional arguments must always come before keyword arguments.\n\nroi4 = calculate_roi(investment, profit=profit)\nprint(roi4)\n\n25.0\n\n\nDefault parameters are useful when you want to provide a default value for a parameter, which is used when no value is provided during the function call. This makes your functions more flexible and easy to use, as you can omit parameters that have a default value.\nTo define a default parameter, assign a value to the parameter in the function definition using =. When the function is called, the default value will be used if no value is provided for that parameter. If a value is provided, it will override the default value.\n\ndef calculate_present_value(cashflow: float, discount_rate: float = 0.1) -&gt; float:\n    return cashflow / (1 + discount_rate)\n\n\n# Uses default discount_rate of 10%\npv = calculate_present_value(cashflow=100.00)\nprint(f\"Present Value: {pv}\")\n\n# Uses discount_rate of 5%\npv2 = calculate_present_value(cashflow=100.00, discount_rate=0.05)\nprint(f\"Present Value: {pv2}\")\n\nPresent Value: 90.9090909090909\nPresent Value: 95.23809523809524\n\n\nParameters with default values must come after parameters without default values. Otherwise, the function call will raise a SyntaxError. When you call a function with default parameters, you can omit any parameters that have a default value. However, when you omit a parameter, you must use keyword parameters to specify the values for the parameters that follow it.\n\n\nPassing arguments: peek under the hood\nPython uses a mechanism called ‚Äúpassing arguments by assignment.‚Äù In simple terms, this means that when you pass an argument to a function, a copy of the reference to the object is made and assigned to the function parameter.\nWhen an immutable object (like a number, string, or tuple) is passed as an argument, it is effectively passed by value. Any modifications made to the parameter within the function do not affect the original object outside the function. Changes to the parameter create a new object rather than modifying the original one.\nOn the other hand, when a mutable object (like a list or dictionary) is passed as an argument, it is effectively passed by reference. Any modifications made to the parameter within the function will affect the original object outside the function. This is because both the parameter and the original object refer to the same memory location, so changes are reflected in both.\n\n\nReturn values\nFunctions can return a value, multiple values, or no value at all. To return a value, use the return keyword followed by the value or expression you want to return. If a function doesn‚Äôt include a return statement, it will implicitly return None. A function can contain multiple return statements, but the execution of the function will stop as soon as any of them is reached.\nA function can return a single value, such as a number, string, or a more complex data structure. A function can also return multiple values, typically in the form of a tuple. This is useful when you need to return several related results from a single function call. If a function doesn‚Äôt explicitly return a value using the return keyword, it will implicitly return None when it reaches the end of the function body.\n\ndef calculate_mean_and_median(numbers: list[float]) -&gt; tuple[float, float]:\n    mean = sum(numbers) / len(numbers)\n\n    # Sort the numbers in ascending order using the sorted() function\n    sorted_numbers = sorted(numbers)\n    length = len(sorted_numbers)\n\n    if length % 2 == 0:\n        median = (sorted_numbers[length // 2 - 1] + sorted_numbers[length // 2]) / 2\n    else:\n        median = sorted_numbers[length // 2]\n\n    return mean, median\n\n\nprices = [150.25, 1200.50, 250.00]\nmean, median = calculate_mean_and_median(prices)\nprint(f\"Mean: {mean}, Median: {median}\")\n\nMean: 533.5833333333334, Median: 250.0\n\n\n\n\nScope\nIn Python, the scope of a variable refers to the region of a program where the variable is accessible and can be referenced. The scope determines the visibility and lifetime of a variable, including where it can be accessed and modified.\nWhen using Python functions, there are two main scopes to consider:\n\nLocal scope (function scope): Variables defined within a function have local scope. They are accessible only within the function where they are defined. Local variables are created when the function is called and destroyed when the function execution completes or reaches a return statement. They are not accessible outside the function.\nGlobal scope (module scope): Variables defined outside of any function in the interactive window or in a Python script, have global scope. They are accessible from anywhere within the program, including all functions.\n\nWhen a function is called, it creates a new local scope, which is independent of the global scope. Inside the function, the local scope takes precedence over the global scope. If a variable is referenced within a function, Python first checks the local scope for its existence. If not found, it then searches the global scope.\n\n# Global variable\nmessage = \"Hello\"\nx = 123\n\n\ndef say_hello(m: str):\n    # Local variable\n    message = \"Hello, World!\"\n    print(f\"local message = {message}\")\n\n    # Local variable, copied from the argument\n    print(f\"local m = {m}\")\n\n    # print(f\"global x inside function = {x}\") \n1\n\n    # Local variable\n    x = len(m)\n    print(f\"local x = {x}\")\n\n    return x\n\n\ny = say_hello(message)\n\nprint(f\"global message = {message}\")\nprint(f\"global x after function = {x}\")\nprint(f\"global y = {y}\")\n\n\n1\n\nThis will access the global x if there is no local variable with the same name. In this specific case, it will cause an error because x is actually defined later in the function.\n\n\n\n\nlocal message = Hello, World!\nlocal m = Hello\nlocal x = 5\nglobal message = Hello\nglobal x after function = 123\nglobal y = 5\n\n\nIf you want to modify a global variable from within a function, you can use the global keyword to indicate that the variable being referred to is a global variable rather than creating a new local variable. However, this is generally not recommended, as it can lead to unexpected side effects and make the code difficult to understand and debug.\nIt is important to carefully manage variable scope to avoid naming conflicts and unintended side effects. Understanding the scope of variables helps in organizing and managing data within functions and modules effectively."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#loops",
    "href": "intro-to-python/python-basics/index.html#loops",
    "title": "Python Basics",
    "section": "Loops",
    "text": "Loops\nLoops enable you to easily perform repetitive tasks or iterate through data structures, such as sequences and collections. Python provides two primary loop constructs: the for loop and the while loop.\n\nfor loops\nFor loops in Python are used to iterate over a sequence (e.g., a list, tuple, or string) or other iterable objects. The loop iterates through each item in the sequence, executing a block of code for each item. The ‚Äòfor‚Äô loop has the following syntax:\nfor item in sequence:\n    # code to execute for each item in the sequence\nAs for function bodies and conditional statements, the code block in a loop must be indented.\n\n\nrange() function\nThe built-in range() function in Python is often used in conjunction with for loops to generate a sequence of numbers. This function can be used to create a range of numbers with a specified start, end, and step size. The syntax for the range function is:\nrange(start, stop, step)\nThe ‚Äòstart‚Äô and ‚Äòstep‚Äô arguments are optional, with default values of 0 and 1, respectively. The ‚Äòstop‚Äô argument is required and defines the upper limit of the range (exclusive).\n\n1for i in range(5):\n    print(i)\n\n\n1\n\nThe range(5) function generates a sequence of numbers from 0 to 4 (inclusive) with a step of 1.\n\n\n\n\n0\n1\n2\n3\n4\n\n\n\n1for i in range(2, 7):\n    print(i)\n\n\n1\n\nThe range(2, 7) function generates a sequence of numbers from 2 to 6 (inclusive) with a step of 1.\n\n\n\n\n2\n3\n4\n5\n6\n\n\n\n1for i in range(1, 11, 2):\n    print(i)\n\n\n1\n\nThe range(1, 11, 2) function generates a sequence of numbers from 1 to 10 (inclusive) with a step of 2.\n\n\n\n\n1\n3\n5\n7\n9\n\n\nYou can use a negative step size to generate a sequence of numbers in reverse order.\n\n1for i in range(5, 0, -1):\n    print(i)\n\n\n1\n\nThe range(5, 0, -1) function generates a sequence of numbers from 5 to 1 (inclusive) with a step of -1 (decreasing).\n\n\n\n\n5\n4\n3\n2\n1\n\n\nYou can use the range() function to generate a sequence of numbers and iterate through them using a for loop to execute some code for each number in the sequence. In this example, we use the range() function to generate a sequence of numbers from 1 to 5 (inclusive) and calculate the compound interest for each year of an investment.\n\nprincipal = 1000\nrate = 0.05\n\nfor year in range(1, 6):\n    interest = principal * ((1 + rate) ** year - 1)\n    print(f\"Year {year}: Interest = {interest:.2f}\")\n\nYear 1: Interest = 50.00\nYear 2: Interest = 102.50\nYear 3: Interest = 157.63\nYear 4: Interest = 215.51\nYear 5: Interest = 276.28\n\n\n\n\ncontinue and break statements\nYou can use the continue and break statements to control the flow of a for loop. The continue statement skips the current iteration and continues with the next one. The break statement terminates the loop and transfers execution to the statement immediately following the loop.\n\nfor i in range(10):\n    if i == 3:\n1        continue\n    elif i == 5:\n2        break\n    print(i)\n\n\n1\n\nSkip the rest of the code in the loop and go to the next iteration\n\n2\n\nExit the loop\n\n\n\n\n0\n1\n2\n4\n\n\n\n\nfor loops with lists\nYou can also loop over a collection of items using the for loop. For example, you can loop over a list of numbers to calculate the sum of all numbers in the list.\n\ndaily_profit_losses = [1500, 1200, 1800, 2300, 900]\n\ntotal_pl = 0\nfor pl in daily_profit_losses:\n    total_pl += pl\n\nprint(f\"Total P&L for the period: {total_pl}\")\n\nTotal P&L for the period: 7700\n\n\n\n\n\n\n\n\nBuilt-in functions\n\n\n\nPython provides several built-in functions that can be used to perform common tasks. For example, the sum() function can be used to calculate the sum of all numbers in a list.\n\ndaily_profit_losses = [1500, 1200, 1800, 2300, 900]\ntotal_pl = sum(daily_profit_losses)\nprint(f\"Total P&L for the period: {total_pl}\")\n\nTotal P&L for the period: 7700\n\n\n\n\nYou can combine two lists of the same length using the zip() built-in function to loop over both lists at the same time.\n\nstock_prices = [150.25, 1200.50, 250.00]\nquantities = [10, 5, 20]\n\ntotal_value = 0\nfor price, quantity in zip(stock_prices, quantities):\n    total_value += price * quantity\n\nprint(f\"Total value of the portfolio: {total_value:.2f}\")\n\nTotal value of the portfolio: 12505.00\n\n\nYou can use the enumerate() function to loop over a list and get the index of each item in the list.\n\ncash_flows = [100, 200, 300, 400, 500]\n\ndiscount_rate = 0.1\n\npresent_values = []\nfor year, cash_flow in enumerate(cash_flows):\n    present_value = cash_flow / (1 + discount_rate) ** year\n    print(f\"Year {year}: Present Value = {present_value:.2f}\")\n\nYear 0: Present Value = 100.00\nYear 1: Present Value = 181.82\nYear 2: Present Value = 247.93\nYear 3: Present Value = 300.53\nYear 4: Present Value = 341.51\n\n\n\n\n\n\n\n\nIterables and iterators\n\n\n\nIn Python, an iterable is an object capable of returning its elements one at a time, such as a list, tuple, or string. An iterator is an object that keeps track of its current position within an iterable and provides a way to access the next element when required.\nMany built-in data types and functions return values in Python are iterables or iterators. For example, the range() function returns an iterator that produces a sequence of numbers. The zip() function returns an iterator that produces tuples containing elements from the input iterables. The enumerate() function returns an iterator that produces tuples containing the index and value of each item in the input iterable.\nThere are many benefits to iterators, such as better memory efficiency and allowing you to work with infinite sequences, such as the sequence of all prime numbers. However, you can‚Äôt print the result of calling an iterator like zip() directly. Instead, you must convert the iterator to a list or another collection using the list() function.\n\nstock_prices = [150.25, 1200.50, 250.00]\nquantities = [10, 5, 20]\n\nzipped = zip(stock_prices, quantities)\n\nprint(f\"zipped: {zipped}\")\nprint(f\"list(zipped): {list(zipped)}\")\n\nzipped: &lt;zip object at 0x1755f6900&gt;\nlist(zipped): [(150.25, 10), (1200.5, 5), (250.0, 20)]\n\n\n\n\n\n\n\nNested for loops\nYou can nest loops. The inner loop will be executed one time for each iteration of the outer loop.\nIn this example, we have a list of products, each with a name, per-item profit margin, and a list of quantities sold at different times. The outer loop iterates through each product, while the inner loop iterates through the quantities for each product. The product‚Äôs profit is calculated by multiplying its margin by the quantity sold and adding it to the product_profit variable. The total_profit variable accumulates the profit for all products.\n\nproducts = [\n    {\"name\": \"Product A\", \"margin\": 10, \"quantities\": [5, 10, 15]},\n    {\"name\": \"Product B\", \"margin\": 20, \"quantities\": [2, 4, 6]},\n    {\"name\": \"Product C\", \"margin\": 30, \"quantities\": [1, 3, 5]},\n]\n\ntotal_profit = 0\n\nfor product in products:\n    product_profit = 0\n    for quantity in product[\"quantities\"]:\n        product_profit += product[\"margin\"] * quantity\n    total_profit += product_profit\n    print(f\"Profit for {product['name']}: {product_profit}\")\n\nprint(f\"Total profit: {total_profit}\")\n\nProfit for Product A: 300\nProfit for Product B: 240\nProfit for Product C: 270\nTotal profit: 810\n\n\n\n\nwhile loops\nWhile loops are used to repeatedly execute a block of code as long as a specified condition is True. The while loop has the following syntax:\nwhile condition:\n    # code to execute while the condition is True\nIn this example, we use a while loop to calculate the number of years it takes for an investment to double at a given interest rate.\n\nprincipal = 1000\nrate = 0.05\nbalance = principal\ntarget = principal * 2\nyears = 0\n\nwhile balance &lt; target:\n    interest = balance * rate\n    balance += interest\n    years += 1\n\nprint(f\"It takes {years} years for the investment to double.\")\n\nIt takes 15 years for the investment to double.\n\n\nYou can use the continue statement to skip the rest of the code in the current iteration and continue with the next one and the break statement to exit a while loop before the condition becomes False."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#list-and-dictionary-comprehensions",
    "href": "intro-to-python/python-basics/index.html#list-and-dictionary-comprehensions",
    "title": "Python Basics",
    "section": "List and dictionary comprehensions",
    "text": "List and dictionary comprehensions\nPython supports list and dictionary comprehensions, which allow you to create lists and dictionaries in a concise and efficient manner by transforming or filtering items from another iterable, such as a range, a tuple or another list. Comprehensions can be confusing at first, but they are a powerful tool worth learning.\n\nList comprehensions\nList comprehension syntax consists of square brackets containing an expression followed by a for clause, then zero or more for or if clauses. The expression can be anything, meaning you can put in all kinds of objects in lists.\n\n# This is perfectly valid:\nsquared1 = []\nfor x in range(10):\n    squared1.append(x * x)\n\nprint(squared1)\n\n# This is much shorter!\nsquared2 = [x * x for x in range(10)]\n\nprint(squared2)\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nYou can use list comprehensions to transform items from a list into a new list using complex expressions.\n\n# Calculate the percentage change for a list of stock prices\nstock_prices = [150.25, 1200.50, 250.00, 175.00, 305.75]\npercentage_changes = [\n    (stock_prices[i + 1] - stock_prices[i]) / stock_prices[i] * 100\n    for i in range(len(stock_prices) - 1)\n]\n\nprint(\"Percentage changes:\", percentage_changes)\n\nPercentage changes: [699.0016638935108, -79.17534360683048, -30.0, 74.71428571428571]\n\n\n\n\nDictionary comprehensions\nSimilar to list comprehensions, dictionary comprehensions use a single line of code to define the structure of the new dictionary.\n\n# Create a dictionary mapping numbers to their squares\nsquares = {i: i**2 for i in range(1, 6)}\n\nprint(squares)\n\n{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n\n\n\nFiltering and transforming\nYou can use conditional statements in list and dictionary comprehensions to filter items from the source iterable.\n\n# Create a dictionary mapping even numbers to their cubes\neven_cubes = {i: i**3 for i in range(1, 6) if i % 2 == 0}\n\nprint(even_cubes)\n\n{2: 8, 4: 64}\n\n\nYou can transform the items in the source iterable before adding them to the new list or dictionary.\n\n# List of stock symbols and prices\nstock_data = [(\"AAPL\", 150.25), (\"GOOG\", 1200.50), (\"MSFT\", 250.00)]\n\n# Create a dictionary mapping lowercase stock symbols to their prices\nstocks = {symbol.lower(): price for symbol, price in stock_data}\n\nprint(stocks)\n\n{'aapl': 150.25, 'goog': 1200.5, 'msft': 250.0}\n\n\n\n\nNested comprehensions\nYou can nest comprehensions inside other comprehensions to create complex data structures.\n\n# Create a list of (stock, prices) tuples\nstock_data = [\n    (\"AAPL\", [150.25, 150.50, 150.75]),\n    (\"GOOG\", [1200.50, 1201.00]),\n    (\"MSFT\", [250.00, 250.25, 250.50, 250.75]),\n]\n\n1stocks = [(symbol, price) for symbol, prices in stock_data for price in prices]\nprint(stocks)\n\n\n1\n\nThe comprehension is evaluated from left to right, so the prices variable is available in the second for clause.\n\n\n\n\n[('AAPL', 150.25), ('AAPL', 150.5), ('AAPL', 150.75), ('GOOG', 1200.5), ('GOOG', 1201.0), ('MSFT', 250.0), ('MSFT', 250.25), ('MSFT', 250.5), ('MSFT', 250.75)]\n\n\n\n\n\n\n\n\nNested comprehensions vs readability\n\n\n\nNested comprehensions with more than two levels can be difficult to read, so you should avoid them if possible. If you find yourself nesting comprehensions, it‚Äôs probably a good idea to use a regular for loop instead. Remember, code readability is more important than brevity."
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#pattern-matching",
    "href": "intro-to-python/python-basics/index.html#pattern-matching",
    "title": "Python Basics",
    "section": "Pattern matching",
    "text": "Pattern matching\nPattern matching is a powerful feature introduced in Python 3.10. It allows you to match the structure of data and execute code based on the shape and contents of that data. It is particularly useful for working with complex data structures and can lead to cleaner and more readable code.\n\n\n\n\n\n\nPython 3.10+ only\n\n\n\nPattern matching is a new feature introduced in Python 3.10, released on October 4, 2021. If you‚Äôre using an older version of Python, or your code will be running on a system with an older version of Python, you should avoid using pattern matching.\n\n\nPattern matching is implemented using the match statement, which is similar to a switch-case statement in other languages but with more advanced capabilities. The match statement takes an expression and a series of cases. Each case is a pattern that is matched against the expression in turn. If the pattern matches, the code in that case is executed, otherwise the next case is checked. The match statement can also have a case with the wildcard pattern _, which will always match. If no pattern matches, a MatchError is raised.\n\ndef process_transaction(transaction: tuple):\n    match transaction:\n        case (\"deposit\", amount):\n            print(f\"Deposit: {amount:.2f}\")\n        case (\"withdraw\", amount):\n            print(f\"Withdraw: {amount:.2f}\")\n        case (\"transfer\", amount, recipient):\n            print(f\"Transfer {amount:.2f} to {recipient}\")\n        case _:\n            print(\"Unknown transaction\")\n\nprocess_transaction((\"deposit\", 1000))\nprocess_transaction((\"burn\", 100.00))\nprocess_transaction((\"transfer\", 500.00, \"John Doe\"))\nprocess_transaction((\"withdraw\", 250.00))\n\nDeposit: 1000.00\nUnknown transaction\nTransfer 500.00 to John Doe\nWithdraw: 250.00"
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#additional-resources",
    "href": "intro-to-python/python-basics/index.html#additional-resources",
    "title": "Python Basics",
    "section": "Additional resources",
    "text": "Additional resources\n\nPython 3.12 documentation\nLubanovic, Bill. Introducing Python, 2nd Edition, O‚ÄôReilly Media, Inc., 2019"
  },
  {
    "objectID": "intro-to-python/python-basics/index.html#footnotes",
    "href": "intro-to-python/python-basics/index.html#footnotes",
    "title": "Python Basics",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nA pseudo-random number is a sequence of numbers that appear random but are generated using a deterministic algorithm.‚Ü©Ô∏é\nI do not recommend using variable-length parameters unless you have a specific need for them, as they can make your code more complex and harder to read and understand.‚Ü©Ô∏é"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "New Year, new blog",
    "section": "",
    "text": "Happy New Year and welcome to the first post of Vincent Codes Finance! As we step into a fresh year, I‚Äôm thrilled to launch this new blog and companion YouTube channel dedicated to Python and coding in empirical finance research. I‚Äôm excited to share my knowledge and experience with you."
  },
  {
    "objectID": "posts/welcome/index.html#about-me",
    "href": "posts/welcome/index.html#about-me",
    "title": "New Year, new blog",
    "section": "About me",
    "text": "About me\nI‚Äôm an Associate Professor of Finance at HEC Montr√©al where I have been teaching Empirical Finance at the Master‚Äôs level since 2020. My research interests include information economics, market microstructure, big data and machine learning applications in finance, fintech, and cybersecurity in finance. I‚Äôm also a Python enthusiast and curious about anything related to coding, data science, and machine learning. See my academic page for more details."
  },
  {
    "objectID": "posts/welcome/index.html#why-this-blog",
    "href": "posts/welcome/index.html#why-this-blog",
    "title": "New Year, new blog",
    "section": "Why this blog?",
    "text": "Why this blog?\nVincent Codes Finance is more than just a blog; it‚Äôs my contribution to enhancing empirical finance research through proficient coding practices. Here, I‚Äôll share my insights, experiences, and love for Python, aiming to elevate the quality and efficiency of research. Whether you‚Äôre a student, a fellow researcher, or an enthusiast, there‚Äôs something here for you.\nMy motivation for creating Vincent Codes Finance is driven by a blend of professional ambition and personal passion:\n\nEnhancing Communication and Presentation Skills: This is one of my New Year‚Äôs resolutions. By regularly writing and producing content, I aim to refine my ability to present complex ideas clearly and engagingly.\nCreating a Valuable Resource: I‚Äôve witnessed firsthand the challenges students and co-authors face when dealing with empirical finance research, especially in coding and data analysis. Vincent Codes Finance is my channel to provide a structured, accessible resource to elevate the quality of their work and mine.\nSharing a Passion for Coding and Tools: Coding is not just about algorithms and syntax; it‚Äôs a way of thinking and problem-solving. I‚Äôm excited to share how powerful coding can be in the realm of finance research and to explore and introduce various computer tools that can transform our research methodologies.\nContributing to the Field: With years of experience under my belt, I believe I have unique insights and skills that can benefit others. By sharing my knowledge, I aim to contribute to the broader community of finance researchers and practitioners.\nPromoting High-Quality, Replicable Research: The landscape of empirical finance is rapidly changing with the increasing importance of data and computational tools. I am committed to promoting practices that ensure research is not only innovative but also replicable and robust, contributing to the credibility and reliability of financial research."
  },
  {
    "objectID": "posts/welcome/index.html#about-vcf",
    "href": "posts/welcome/index.html#about-vcf",
    "title": "New Year, new blog",
    "section": "About VCF",
    "text": "About VCF\nWe‚Äôll start with the basics, setting a strong foundation for everyone. The initial posts will cover installing Python, setting up your development environment, understanding Python fundamentals, and introducing data analysis using pandas. These topics are essential for anyone who wants to get started with Python and coding in empirical finance research and will be released throughout January to align with my current teaching.\nCome February, we‚Äôll dive into more advanced topics such as handling dates and timestamps efficiently, diverse file formats for research data, using git and GitHub for collaboration, and techniques to speed up your computations.\nYour input is invaluable! I encourage you to send in your topic suggestions, questions, or any insights you might have. For all blog-related inquiries, please reach out to me at vincent@codes.finance.\nFollow Along! Don‚Äôt miss out on any updates! Subscribe to the newsletter, the YouTube channel, the blog‚Äôs RSS feed, and follow me on X. Let‚Äôs raise the bar for empirical finance research together.\nI look forward to sharing this journey with you and seeing where it takes us.\nCheers to a year of coding, discovery, and breakthroughs in empirical finance research!\n- Vincent"
  },
  {
    "objectID": "posts/install-python-312/index.html",
    "href": "posts/install-python-312/index.html",
    "title": "Installing Python 3.12",
    "section": "",
    "text": "In this short tutorial, I cover installing Python 3.12 and the related tools for a complete coding environment."
  },
  {
    "objectID": "posts/install-python-312/index.html#what-you-need-for-a-complete-python-environment",
    "href": "posts/install-python-312/index.html#what-you-need-for-a-complete-python-environment",
    "title": "Installing Python 3.12",
    "section": "What you need for a complete Python environment",
    "text": "What you need for a complete Python environment\nThe most common way to use Python is to install it locally on your computer. The instructions below will guide you through the process of installing the following tools:\n\nPython: The Python interpreter, which allows you to run Python code.\nPoetry: A package manager for Python. I use it to manage the external libraries used in projects. Poetry makes it easy to install and update libraries on a per-project basis, and to make sure all collaborators use the same library version.\nVisual Studio Code: Visual Studio Code is a free source code editor made by Microsoft. Features include support for debugging, syntax highlighting and intelligent code completion. Users can install extensions that add additional functionality.\n\nWe will also install the following tools that are not required to run Python code, but are useful when working on projects with code:\n\nGit and GitHub: I use Git to manage my code and GitHub to host my code online and collaborate with others. Git is a version control system that tracks code changes and keeps a full history of changes. GitHub is a website that hosts Git repositories and provides additional features for collaboration such as issue tracking and pull requests.\n\n\n\n\n\n\n\nPoetry vs Anaconda\n\n\n\n\n\nMost Python projects use external libraries. For example, we use the pandas library for data analysis. To manage these libraries, we need a package manager. I recommend using Poetry. Anaconda was my package manager of choice for many years and it remains very popular, but like many I recently switched to Poetry. Here is my view of the pros and cons of each:\n\nPoetry\n\nPros\n\nFlexibility with Python version It is very easy to specify which version of Python an environment should use and to change it later.\nDependency management Poetry makes it easy to install and update libraries on a per-project basis, and to make sure all collaborators use the same library version.\nPerformance Poetry is much faster than Anaconda.\nSimple to update Poetry is easy to update, and it is easy to update the libraries in a project.\n\n\n\nCons\n\nInitial setup The initial setup is a bit more complex than Anaconda, but if you follow the instructions below, it should be easy.\nLearning curve Poetry is a new tool, so there is a learning curve. However, it is not that difficult to learn.\nNot as widely used (newer) Poetry is a new tool, so it is not as widely used as Anaconda. However, it is gaining popularity very quickly.\n\n\n\n\nAnaconda\n\nPros\n\nEase of use Anaconda is very easy to install and use.\nWide adoption in science and data analysis Anaconda is very popular in the scientific community, so it is easy to find help online.\n\n\n\nCons\n\nBloat and performance Anaconda is very bloated and slow. It is much slower than Poetry.\nUpdates Updating Anaconda is a pain. It is also difficult to update the libraries in a project when a conflict arises.\nComplexity when there are issues Anaconda is a complex tool, so when there are issues, it can be difficult to troubleshoot.\n\nAnother important difference is that Anaconda is a complete environment. Anaconda comes with many libraries pre-installed, so you can start working on projects right away. This might seem like a good thing, but I find that it is better to start with a clean environment and install only the libraries you need for each project. This way, you know exactly which libraries are used in each project, which is part of the best practices for reproducible research."
  },
  {
    "objectID": "posts/install-python-312/index.html#video-tutorial",
    "href": "posts/install-python-312/index.html#video-tutorial",
    "title": "Installing Python 3.12",
    "section": "Video tutorial",
    "text": "Video tutorial\nThe video below shows how to install Python 3.12 and the related tools on macOS using Homebrew, which is my preferred method for macOS. The instructions for a manual installation on macOS or for other platforms are provided below the video."
  },
  {
    "objectID": "posts/install-python-312/index.html#installation",
    "href": "posts/install-python-312/index.html#installation",
    "title": "Installing Python 3.12",
    "section": "Installation",
    "text": "Installation\n\n macOS (preferred) macOS (manual) Linux Windows\n\n\nIf you are using macOS, I recommend using Homebrew to install Python and the other tools. Homebrew is a package manager for macOS that allows you to install and update software from the command line. It simplifies the installation process and makes it easy to keep your software up-to-date. If you prefer not to use Homebrew, you can install Python and the other tools manually using the official installers.\nFirst, you need to open the Terminal app. You can find it in the Applications/Utilities folder, or by using Spotlight (press ‚åò + Space and type Terminal).\n\nXcode command-line tools\nHomebrew requires the Xcode command-line tools from Apple. If so, you can install them from the terminal:\nxcode-select --install\n\n\nHomebrew\nTo install Homebrew (brew for short), run the following command in the Terminal app:\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nOnce brew is installed, look at the output of the previous command. It should tell you if you need to add Homebrew to your path. If so, copy the command it suggests and run it in the Terminal app.\n\n\nPython\n\n\n\n\n\n\nIf you have Anaconda installed\n\n\n\nIf you have Anaconda installed, you should uninstall it before installing Python with brew. Follow the instructions here to uninstall Anaconda.\n\n\n\n:::\nTo install Python with brew, run the following command in the Terminal app:\n\n```bash\nbrew install python@3.12 python@3.11 python@3.10\nThis will install the latest version of Python (3.12), as well as the previous two versions. This is useful because some libraries are not compatible with the latest version of Python, so you might need to use an older version for some projects.\nTo make sure that the latest version of Python is used by default, run the following command in the Terminal app:\necho 'export PATH=\"$HOMEBREW_PREFIX/opt/python@3.12/libexec/bin:$PATH\"' &gt;&gt; ~/.zshrc\nYou should now have Python 3.12 installed. To check, run the following command in the Terminal app:\npython3 --version\nIt should also work with the python command:\npython --version\nIf the two versions are different, it means that python still links to the system Python. To fix this, run the following command in the Terminal app:\necho 'alias python=\"python3\"' &gt;&gt; ~/.zshrc\n\n\n\n\n\n\nHomebrew and the base environment\n\n\n\n\n\nBy default, Homebrew will lock the base Python environment, which means that you cannot install additional libraries in the base environment. This means that you cannot easily install pandas or other libraries in the base environment.\nI consider this a good thing because it prevents you from accidentally breaking your Python installation and it forces you to use virtual environments, which is a good practice. However, if you want to change this behavior, there are a few workarounds.\nIsn‚Äôt it more convenient to have a base environment with all the libraries you need? Maybe, but eventually, it can lead to conflicts, difficult updates, and other annoying issues. My approach is to keep a sandbox environment with all the libraries I use regularly and to create a new environment for each project. This way, I can easily update the libraries in the sandbox environment, and I can delete the project environments when I am done with the project. This prevents accumulating virtual environments for discarded projects. If there is a conflict between two libraries in my sandbox environment, I can easily create a new one without reinstalling everything.\n\n\n\n\n\nPoetry\nTo install Poetry with brew, run the following command in the Terminal app:\nbrew install poetry\nBy default, Poetry installs Python for each project in the ~/Library/Caches/pypoetry/virtualenvs/ directory. I prefer to have it in the project directory. That way if, I delete the directory, then the environment is deleted as well, which prevents accumulating virtual environments for discarded projects. To enable this, run the following command:\npoetry config virtualenvs.in-project true\n\n\nVisual Studio Code\nTo install Visual Studio Code with brew, run the following command in the Terminal app:\nbrew install --cask visual-studio-code\n\n\n\n\n\n\n--cask option\n\n\n\nYou might have noticed that we used the --cask option to install Visual Studio Code.\nBrew offers two types of packages: formulae and casks. Formulae are used to install command-line tools, while casks are used to install graphical applications that go in the Applications folder.\nMost Mac applications can be installed using brew, just search for them on the homepage to find the name of the cask. For example, to install Google Chrome, you would run brew install --cask google-chrome.\n\n\n\n\nGit and GitHub\nGit is already installed on your Mac as a command-line tool because you have installed the Xcode tools. Still, I recommend installing the latest version using brew:\nbrew install git\nTo follow along with the upcoming tutorials, or to collaborate efficiently with others, you will also need to use GitHub. For this, you will want to use the GitHub CLI (gh for short) or the GitHub Desktop app. Both can be installed using brew:\nbrew install gh\nbrew install --cask github\n\n\n\n\n\n\n\n\n\nYou should consider Homebrew\n\n\n\nI know that using command-line instructions to install software can be intimidating at first, but it is not that difficult. In the long run, it is much easier to use Homebrew than to install everything manually. If you are not convinced, you can follow the manual installation instructions below, but I recommend that you come back later and try Homebrew.\n\n\n\nPython\nmacOS comes with Python pre-installed. However, it might not be the latest version of Python, so I recommend installing a fresh version from the official distribution at python.org.\nTo complete the installation, go to Applications/Python 3.12 and double-click Install Certificates.command.\nSee this thread on StackOverflow for more details.\n\n\nPoetry\nInstallation instructions can be found here.\nNote: If you get an SSH-related issue, go back up to the Python installation instruction and run Install Certificates.command.\nBy default, Poetry installs Python for each project in the ~/Library/Caches/pypoetry/virtualenvs/ directory. I prefer to have it in the project directory, that way if, I delete the directory, then the environment is deleted as well, which prevents accumulating virtual environments for discarded projects. To enable this, run the following command in the Terminal app. You can find it in the Applications/Utilities folder, or by using Spotlight (press ‚åò + Space and type Terminal).\npoetry config virtualenvs.in-project true\nIf you get an error message that poetry is not found, you need to add it to your path. To do so, open the Terminal app and run the following command:\nexport PATH=\"/Users/{user}/.local/bin:$PATH\"\nwhere {user} is your username. You can find it by running the following command in the Terminal app:\nwhoami\n\n\nVisual Studio Code\nDownload Visual Studio Code from code.visualstudio.com.\n\n\nGit and GitHub\nGit might already be installed on your Mac as a command-line tool if you have installed the Xcode tools. If not, you can get the official installer. You can also use Git directly in VS Code, or using a GUI client such as GitHub Desktop. I prefer to use the VS Code integration or the command-line tool, but many beginners prefer to use GitHub Desktop.\n\n\n\nTo be honest, if you‚Äôre using Linux, you probably already know how to install Python and other tools. The instructions below are for manual installation, but you probably want to use your distribution‚Äôs package manager instead.\n\nPython\nMost Linux distributions come with Python pre-installed. However, it might not be the latest version of Python, so I recommend installing a fresh version from the official distribution at python.org.\n\n\nPoetry\nInstallation instructions can be found here.\nBy default, Poetry installs Python for each project in the ~/.cache/pypoetry/virtualenvs/ directory. I prefer to have it in the project directory, that way if, I delete the directory, then the environment is deleted as well, which prevents accumulating virtual environments for discarded projects. To enable this, run the following command in the terminal:\npoetry config virtualenvs.in-project true\n\n\nVisual Studio Code\nDownload Visual Studio Code from code.visualstudio.com.\n\n\nGit and GitHub\nGit is probably already installed on Linux as a command-line tool. You can also use Git directly in VS Code, or using a GUI client such as GitHub Desktop. I prefer to use the VS Code integration or the command-line tool, but many beginners prefer to use GitHub Desktop.\n\n\n\n\nPython\nWindows does not have a built-in Python interpreter, so you will need to install it. I recommend installing a fresh version from the Microsoft Store. You can also install it from the official distribution at python.org, but the Microsoft Store version is easier to install and is more consistent in setting up the environment variables correctly.\n\n\nPoetry\nInstallation instructions can be found here.\nNote: Unless you are using the Windows Subsystem for Linux (WSL), you should follow the instructions for Windows PowerShell.\nBy default, Poetry installs Python for each project in a global directory. I prefer to have it in the project directory, that way if, I delete the directory, then the environment is deleted as well, which prevents accumulating virtual environments for discarded projects. To enable this, run the following command in Powershell:\npoetry config virtualenvs.in-project true\n\n\nVisual Studio Code\nDownload Visual Studio Code from code.visualstudio.com.\n\n\nGit and GitHub\nTo use Git on Windows, you need to install the Git client, which is a command-line tool.\nYou can also use Git directly in VS Code, or using a GUI client such as GitHub Desktop, but you need to first install the Git client. I prefer to use the VS Code integration or the command-line tool, but many beginners prefer to use GitHub Desktop."
  },
  {
    "objectID": "posts/install-python-312/index.html#github.com-optional",
    "href": "posts/install-python-312/index.html#github.com-optional",
    "title": "Installing Python 3.12",
    "section": "GitHub.com (optional)",
    "text": "GitHub.com (optional)\nYou do not need a GitHub account to have a complete Python environment. However, I recommend creating one because it will be useful later when we start working on projects.\nTo follow the upcoming tutorials, you will need to create a GitHub account. You can create a free account at https://github.com/.\nGitHub offers many benefits to students and educators, including free access to GitHub Copilot and extra free hours for GitHub Codespaces. I highly recommend applying at GitHub Education if you are eligible."
  },
  {
    "objectID": "posts/install-python-312/index.html#creating-a-sandbox-environment",
    "href": "posts/install-python-312/index.html#creating-a-sandbox-environment",
    "title": "Installing Python 3.12",
    "section": "Creating a sandbox environment",
    "text": "Creating a sandbox environment\nI like to have a sandbox environment with all the libraries I use regularly that are not tied to a project. That way, if I want to try something quickly like reading a CSV file to look at it, I can do it without creating a new project. It is common to use the default (or base) environment for this, but I prefer to create a separate environment. This way, I can easily update the libraries in the sandbox environment. If there is a conflict between two libraries in my sandbox environment, I can easily create a new one without reinstalling everything.\nFor my sandbox environment, I will want at least the following libraries:\n\npandas: Data analysis library\nnumpy: Numerical computing library\nscipy: Scientific computing library\nmatplotlib: Plotting library\nseaborn: Plotting library\nstatsmodels: Statistical models\nscikit-learn: Machine learning library\nlinearmodels: Linear models for Python\npyarrow: Library for working with parquet files\njupyter: for Jupyter notebooks and the VS Code Python interactive window\npytest: Testing framework\n\nTo create this sandbox environment, I will use Poetry. First, I need to create a new directory for the environment. I will call it sandbox. Then, I need to create a new project in this directory:\nmkdir ~/Documents/sandbox\ncd ~/Documents/sandbox\npoetry init\nFollow the instructions to create the project. You can leave the default values for most questions, but do not add any dependencies (it‚Äôs simpler to add them after).\nThis creates a pyproject.toml file in the sandbox directory. This file contains the list of dependencies for the project (which will be empty for now).\nOnce the project is created, you can add the dependencies:\npoetry add pandas numpy scipy matplotlib seaborn statsmodels scikit-learn linearmodels pyarrow jupyter pytest\nThis step updates the pyproject.toml file and creates a poetry.lock file, which contains the exact version of each dependency. This file is used to make sure that all collaborators use the same version of each library. Note that because our dependencies are built on top of other libraries, Poetry will also install the dependencies of our dependencies.\nTo activate the environment in the terminal, run the following command:\npoetry shell\n\n\n\n\n\n\nNote\n\n\n\nIf at some point you get the following error message, you can safely ignore it:\nThe current project could not be installed: No file/folder found for package sandbox\nIt is because Poetry is trying to install the sandbox package, which does not exist. This does not affect the creation of the environment and the installation of the dependencies. I will cover the intricacies of Poetry in a future post."
  },
  {
    "objectID": "posts/install-python-312/index.html#configuring-visual-studio-code",
    "href": "posts/install-python-312/index.html#configuring-visual-studio-code",
    "title": "Installing Python 3.12",
    "section": "Configuring Visual Studio Code",
    "text": "Configuring Visual Studio Code\nVisual Studio Code is a free source code editor made by Microsoft. Features include support for debugging, syntax highlighting and intelligent code completion. While there are some built-in features for Python, most of the functionality comes from extensions. What I recommend is to use the profile feature of VS Code, which lets you define a set of extensions for each use case. For example, you can have a profile for Python development, another for R development, and another for LaTeX editing. This way, you can have a clean installation of VS Code and only install the extensions you need for each profile. Furthermore, each profile can have its specific settings and theming options.\nTo create a profile, click on the profile icon in the bottom left corner of the VS Code window. Then, under the Profiles section, click on Create Profile.\n\n\n\n\n\nGive the profile a name and select a distinctive icon. Make sure to copy from the Data Science template, which will install all the extensions you need for data analysis with Python.\n\n\n\n\n\nVS Code works best when you have a project (directory) open. To open a project, select Open Folder from the File menu and select the folder you want to open, for example, the sandbox folder we created earlier.\nTo open an interactive window, bring up the command palette by pressing ‚åò + Shift + P (or Ctrl + Shift + P on Windows and Linux) and type Python: Create Interactive Window.\nAt this point, VS Code should have detected the virtual environment created by Poetry and should have asked you if you want to use it. If not, you can select it manually by clicking on the Python version in the top right corner of the interactive window."
  },
  {
    "objectID": "posts/install-python-312/index.html#github-codespaces",
    "href": "posts/install-python-312/index.html#github-codespaces",
    "title": "Installing Python 3.12",
    "section": "Python in the cloud using Github Codespaces",
    "text": "Python in the cloud using Github Codespaces\nMany online platforms allow you to develop and run Python code without installing anything on your computer. If you want to use a cloud-based solution, I recommend using GitHub Codespaces.\nAll you need is a GitHub account. However, note that GitHub Codespaces is not free. At the time of this writing, you get 60 hours per month for free, or 90 hours if you signed up for the GitHub Student Developer Pack (this is for a 2-core machine, which is the smallest machine available). After that, you have to pay for it (the current rate is USD 0.18 per hour).\nMake sure to shut down your Codespace when you are not using it, otherwise you will run out of free hours very quickly.\n\nOther cloud alternatives\nThere are many other cloud-based alternatives. However, most are based on Jupyter notebooks, which can be interesting when you are learning Python, but are not ideal for robust, replicable research (watch out in the future for a video rant on why I don‚Äôt like Juptyer notebooks). Some of the most popular alternatives are:\n\nGoogle Colab\nCocalc\nWRDS Jupyter Hub (requires a WRDS subscription through your institution)"
  },
  {
    "objectID": "posts/install-python-312/index.html#whats-next",
    "href": "posts/install-python-312/index.html#whats-next",
    "title": "Installing Python 3.12",
    "section": "What‚Äôs next?",
    "text": "What‚Äôs next?\nNow that you have a complete Python environment, you can start learning Python. Watch out for my upcoming tutorials on Python for finance research in the coming days."
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html",
    "href": "posts/panel-ols-standard-errors/index.html",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "",
    "text": "In this post, I show how to estimate standard errors in panel data with Python and the linearmodels library.\nMore specifically, I show how to estimate the following class of models:\nIf you just want the code examples with no explanations, just to the cheat sheet at the end of the post."
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#panel-data",
    "href": "posts/panel-ols-standard-errors/index.html#panel-data",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "Panel data",
    "text": "Panel data\nOne of the most common tasks in finance research is to estimate standard errors in panel data. Linear panel data models have the following form:\n\\[\ny_{it} =  \\alpha_i + \\alpha_t + x_{it}'\\beta  + \\epsilon_{it},\n\\]\nwhere \\(y_{it}\\) is the dependent variable for entity \\(i\\in [1,I]\\) at time \\(t\\in [1,T]\\), \\(\\alpha_i\\) is an entity fixed effect, \\(\\alpha_t\\) is a time fixed effect, \\(x_{it}\\) is a vector of independent variables, \\(\\beta\\) is a vector of coefficients, and \\(\\epsilon_{it}\\) is the error term. For the sake of simplicity, in the rest of this post, I assume that the entity is a firm and the time is a year. The error term can be correlated across firms and years and can be heteroskedastic.\nSome of the discussion in this post uses the matrix form of the model for simplicity:\n\\[\n\\mathbf{y} = \\mathbf{X}\\beta + \\mathbf{\\epsilon},\n\\]\nwhere \\(\\mathbf{y}\\) is a \\(N \\times 1\\) vector of dependent variables, \\(\\mathbf{X}\\) is a \\(N \\times K\\) matrix of independent variables, \\(\\beta\\) is a \\(K \\times 1\\) vector of coefficients, and \\(\\mathbf{\\epsilon}\\) is a \\(N \\times 1\\) vector of error terms. The number of observations is \\(N\\) and the number of independent variables is \\(K\\). For a balanced panel in which each firm is observed for the same number of years, \\(N=I \\times T\\).\n\n\n\n\n\n\nMore on matrix form representation\n\n\n\n\n\nIf the model includes fixed effects, we assume that the vector \\(\\mathbf{y}\\) and the matrix \\(\\mathbf{X}\\) are demeaned by the relevant fixed effect.\nIt is then common to stack the observations for each entity. For example, if we have \\(I\\) firms and \\(T\\) years, the vector \\(\\mathbf{y}\\) of elements \\(y_{i,t}\\) is defined as:\n\\[\n\\mathbf{y} = \\left[\\begin{array}{c}y_{1,1}\\\\ y_{1,2}\\\\ \\vdots  \\\\ y_{1, T} \\\\ y_{2,1}\\\\ y_{2,2}\\\\ \\vdots  \\\\ y_{2, T}\\\\ y_{I,1}\\\\ \\vdots  \\\\ y_{I, T} \\end{array} \\right],\n\\]\nThe matrix \\(\\mathbf{X}\\) formed with vectors \\(x_{i,t}\\) is defined as:\n\\[\n\\mathbf{X} = \\left[\\begin{array}{ccccc}\nx_{1, 1}^{(1)} & x_{1, 1}^{(2)} & \\cdots & x_{1, 1}^{(K-1)} & x_{1,1}^{(K)} \\\\\nx_{1, 2}^{(1)} & x_{1, 2}^{(2)} & \\cdots & x_{1, 2}^{(K-1)} & x_{1,2}^{(K)} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\nx_{1, T}^{(1)} & x_{1, T}^{(2)} & \\cdots & x_{1, T}^{(K-1)} & x_{1,T}^{(K)} \\\\\nx_{2, 1}^{(1)} & x_{2, 1}^{(2)} & \\cdots & x_{2, 1}^{(K-1)} & x_{2,1}^{(K)} \\\\\nx_{2, 2}^{(1)} & x_{2, 2}^{(2)} & \\cdots & x_{2, 2}^{(K-1)} & x_{2,2}^{(K)} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\nx_{2, T}^{(1)} & x_{2, T}^{(2)} & \\cdots & x_{2, T}^{(K-1)} & x_{2,T}^{(K)} \\\\\nx_{I, 1}^{(1)} & x_{I, 1}^{(2)} & \\cdots & x_{I, 1}^{(K-1)} & x_{I,1}^{(K)} \\\\\nx_{I, 2}^{(1)} & x_{I, 2}^{(2)} & \\cdots & x_{I, 2}^{(K-1)} & x_{I,2}^{(K)} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\nx_{I, T}^{(1)} & x_{I, T}^{(2)} & \\cdots & x_{I, T}^{(K-1)} & x_{I,T}^{(K)}\n\\end{array} \\right],\n\\]\nwhere \\(x_{i,t}^{(j)}\\) is the \\(j\\)-th element of the vector \\(x_{i,t}\\).\nFinally, the \\(\\beta\\) vector is defined as usual:\n\\[\n\\beta = \\left[\\begin{array}{c}\\beta_1 \\\\ \\beta_2 \\\\ \\vdots \\\\ \\beta_{K-1} \\\\ \\beta_{K} \\end{array} \\right].\n\\]\n\n\n\nThe goal is then to estimate the coefficients \\(\\beta\\) and their associated standard errors. The standard errors are important because they allow us to perform statistical inference. For example, we can test whether the coefficients are statistically different from zero.\nIn his seminal paper, Petersen (2008) compares the performance of different standard errors estimators in panel data. In addition, he provides programming advice on how to estimate standard errors in panel data with Stata and other languages, but not for Python.\nIn this post, I explain how to estimate standard errors in panel data with Python and the linearmodels library. I do so by replicating the sample results from Petersen‚Äôs test data page in Python, and cover a few more standard errors estimators that are useful in finance research.\nI use the test data set provided by Mitchell Petersen and available here. The data set contains 500 firms and 10 years.\n\nimport pandas as pd\n\ndf = pd.read_table(\n    \"http://www.kellogg.northwestern.edu/faculty/petersen/htm/papers/se/test_data.txt\",\n    names=[\"firmid\", \"year\", \"x\", \"y\"],\n    delim_whitespace=True,\n)\ndf\n\n\n\n\n\n\n\n\nfirmid\nyear\nx\ny\n\n\n\n\n0\n1\n1\n-1.113973\n2.251535\n\n\n1\n1\n2\n-0.080854\n1.242346\n\n\n2\n1\n3\n-0.237607\n-1.426376\n\n\n3\n1\n4\n-0.152486\n-1.109394\n\n\n4\n1\n5\n-0.001426\n0.914686\n\n\n...\n...\n...\n...\n...\n\n\n4995\n500\n6\n-0.077057\n3.720502\n\n\n4996\n500\n7\n0.218847\n0.559121\n\n\n4997\n500\n8\n-0.155530\n-3.766785\n\n\n4998\n500\n9\n-0.040172\n0.903354\n\n\n4999\n500\n10\n-0.001172\n-0.529761\n\n\n\n\n5000 rows √ó 4 columns"
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#linearmodels",
    "href": "posts/panel-ols-standard-errors/index.html#linearmodels",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "linearmodels",
    "text": "linearmodels\nThe linearmodels library is a Python package written by Kevin Sheppard at the University of Oxford that extends the statsmodels library with functions commonly used in financial econometrics. Of note, the documentation is quite good and the library is actively maintained.\n\nInstallation\nYou can install the library with your package manager of choice:\npoetry:\npoetry add linearmodels\npip:\npip install linearmodels\nconda (linearmodels is not available in the default conda channel, but it is available in the conda-forge channel):\nconda install -c conda-forge linearmodels\n\n\nUsage\nThe library is easy to use, and intuitive for anyone familiar with statsmodels. In this post, I will use two model types: PanelOLS and FamaMacBeth. As their names imply, the PanelOLS class is used to estimate panel data models, and the FamaMacBeth class is used to estimate Fama-MacBeth regressions. The library also provides implementations for random effects and first differences models, and for between estimation and pooled OLS estimators. In addition to panel data models, the library also provides implementations for instrumental variables models (including 2SLS, 3SLS, GMM, and SUR) and for estimating linear factor models.\nA key particularity of linearmodels is that it uses the indexing capabilities of pandas to identify the panel data structure. In particular, the DataFrame that contains your panel data must have a MultiIndex with the entity dimension in the first level and the time dimension in the second level:\n\ndf = df.set_index([\"firmid\", \"year\"])\ndf\n\n\n\n\n\n\n\n\n\nx\ny\n\n\nfirmid\nyear\n\n\n\n\n\n\n1\n1\n-1.113973\n2.251535\n\n\n2\n-0.080854\n1.242346\n\n\n3\n-0.237607\n-1.426376\n\n\n4\n-0.152486\n-1.109394\n\n\n5\n-0.001426\n0.914686\n\n\n...\n...\n...\n...\n\n\n500\n6\n-0.077057\n3.720502\n\n\n7\n0.218847\n0.559121\n\n\n8\n-0.155530\n-3.766785\n\n\n9\n-0.040172\n0.903354\n\n\n10\n-0.001172\n-0.529761\n\n\n\n\n5000 rows √ó 2 columns\n\n\n\nYou define models by passing the dependent variable and the exogenous variables to the model class. Alternatively, following statsmodels, linearmodels leverages the patsy formula language to provide a more intuitive way to define models. For example, the following two lines of code are equivalent:\nmod = PanelOLS(data[\"y\"], data[[\"x1\", \"x2\"]])\nmod = PanelOLS.from_formula(formula=\"y ~ x1 + x2\", data)\nYou then estimate models by calling the fit() method. The fit() method returns a linearmodels regression results object, which contains the estimated coefficients, standard errors, and other statistics. The linearmodels results object is similar to the statsmodels results object, but it contains additional methods and attributes that are useful for panel data models."
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#ols-coefficients-and-standard-errors",
    "href": "posts/panel-ols-standard-errors/index.html#ols-coefficients-and-standard-errors",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "OLS coefficients and standard errors",
    "text": "OLS coefficients and standard errors\nThe first model I estimate is a vanilla OLS model.\nThe OLS estimator is the most common estimator in finance research. It is also the most efficient estimator when the errors are homoskedastic and uncorrelated across entities and time.\nThe OLS estimator is defined as:\n\\[\n\\hat{\\beta}_{OLS} = (\\mathbf{X}'\\mathbf{X})^{-1}\\mathbf{X}'\\mathbf{y},\n\\]\nwhere \\(\\mathbf{X}\\) is the matrix of exogenous variables and \\(\\mathbf{y}\\) is the vector of dependent variables. The covariance matrix \\(\\Sigma\\) of the estimator is defined as:\n\\[\n\\Sigma_{OLS}  =\\sigma_{\\mathbf{\\epsilon}}^{2}\\cdot\\left(\\mathbf{X}^{\\prime}\\mathbf{X}\\right)^{-1},\n\\]\nwhere \\(\\sigma_{\\mathbf{\\epsilon}}^{2}\\) is usually estimated with the residuals \\(\\mathbf{\\hat{e}}=( \\mathbf{y}-\\mathbf{X}\\hat{\\beta}_{OLS})\\) from the OLS regression:\n\\[\n\\hat{\\sigma}_{\\mathbf{\\epsilon}}^{2} =\\frac{1}{N-K}\\mathbf{\\hat{e}}'\\mathbf{\\hat{e}}.\n\\]\nThe PanelOLS class can be used to estimate OLS models. The following code estimates the OLS coefficients and standard errors:\n\nfrom linearmodels import PanelOLS\n\nmod = PanelOLS.from_formula(\"y ~ 1 + x\", df)\n\nres = mod.fit()\nres.summary\n\n\nPanelOLS Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.2078\n\n\nEstimator:\nPanelOLS\nR-squared (Between):\n0.2208\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1907\n\n\nDate:\nFri, Jan 19 2024\nR-squared (Overall):\n0.2078\n\n\nTime:\n08:23:25\nLog-likelihood\n-1.057e+04\n\n\nCov. Estimator:\nUnadjusted\n\n\n\n\n\n\nF-statistic:\n1310.7\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4998)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n1310.7\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4998)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nIntercept\n0.0297\n0.0284\n1.0466\n0.2954\n-0.0259\n0.0853\n\n\nx\n1.0348\n0.0286\n36.204\n0.0000\n0.9788\n1.0909\n\n\n\n\n\n\nNote that because the intercept is usually excluded by default from panel data models because the use of fixed-effects renders it redundant, we need to add it manually to the model by adding 1 to the formula."
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#white-standard-errors",
    "href": "posts/panel-ols-standard-errors/index.html#white-standard-errors",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "White standard errors",
    "text": "White standard errors\nThe OLS estimator standard errors are consistent when the errors are homoskedastic and uncorrelated across entities and time. In this case, the OLS estimator is unbiased and consistent. However, this is not usually the case with financial data, where the errors are often heteroskedastic and correlated across entities and/or time. In this case, the OLS estimator is biased and inconsistent, and the standard errors are incorrect.\nA common solution to this problem is to use heteroskedasticity-robust standard errors. The most common heteroskedasticity-robust standard errors estimator is the White estimator, which is defined as\n\\[\n\\hat{\\Sigma}_{White} = (X' X)^{-1}\\cdot\\left[X' \\cdot\\text{diag}(\\mathbf{\\hat{e}}^{2})  \\cdot X\\right] \\cdot\\left(X' X\\right)^{-1},\n\\]\nwhere \\(\\text{diag}(\\mathbf{\\hat{e}}^{2})\\) is a diagonal matrix with the squared residuals \\(\\mathbf{\\hat{e}}^{2}\\) on the diagonal, i.e., with the square of the j-th residual \\(\\hat{e}_{j}^{2}\\) at position \\((j,j)\\) and \\(0\\) elsewhere.\nThe PanelOLS class can be used to estimate OLS models with White standard errors. The following code estimates the OLS coefficients and White standard errors:\n\nres = mod.fit(cov_type=\"robust\")\nres.summary\n\n\nPanelOLS Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.2078\n\n\nEstimator:\nPanelOLS\nR-squared (Between):\n0.2208\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1907\n\n\nDate:\nFri, Jan 19 2024\nR-squared (Overall):\n0.2078\n\n\nTime:\n08:23:25\nLog-likelihood\n-1.057e+04\n\n\nCov. Estimator:\nRobust\n\n\n\n\n\n\nF-statistic:\n1310.7\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4998)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n1328.2\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4998)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nIntercept\n0.0297\n0.0284\n1.0465\n0.2954\n-0.0259\n0.0853\n\n\nx\n1.0348\n0.0284\n36.444\n0.0000\n0.9792\n1.0905\n\n\n\n\n\n\nThe estimated coefficients are the same as with the OLS standard errors, but the standard errors are different. In turn, all statistical measures that depend on the standard errors, such as t-statistics and p-values, are different."
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#clustered-standard-errors",
    "href": "posts/panel-ols-standard-errors/index.html#clustered-standard-errors",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "Clustered standard errors",
    "text": "Clustered standard errors\nBeyond the basics, a common concern with panel is that the errors are correlated across entities and/or time. In this case, the OLS estimator is biased and inconsistent, and the standard errors are incorrect. Clustering standard errors is a widely-used adjustment for this problem.\nThe intuition behind clustering is that often the errors are correlated within groups, but not across groups. For example, in a panel data set with firms, the errors could correlated within the observations of a firm, but not across firms. In this case, we can cluster the standard errors by firm to obtain consistent standard errors. Implicitly we assume that the errors have the following structure:1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirm 1\n\n\nFirm 2\n\n\nFirm 3\n\n\n\n\n\nFirm 1\n\\(\\epsilon_{11}^2\\)\n\\(\\epsilon_{11}\\epsilon_{12}\\)\n\\(\\epsilon_{11}\\epsilon_{13}\\)\n0\n0\n0\n0\n0\n0\n\n\n\n\\(\\epsilon_{12}\\epsilon_{11}\\)\n\\(\\epsilon_{12}^2\\)\n\\(\\epsilon_{12}\\epsilon_{13}\\)\n0\n0\n0\n0\n0\n0\n\n\n\n\\(\\epsilon_{13}\\epsilon_{11}\\)\n\\(\\epsilon_{13}\\epsilon_{12}\\)\n\\(\\epsilon_{13}^2\\)\n0\n0\n0\n0\n0\n0\n\n\nFirm 2\n0\n0\n0\n\\(\\epsilon_{21}^2\\)\n\\(\\epsilon_{21}\\epsilon_{22}\\)\n\\(\\epsilon_{21}\\epsilon_{23}\\)\n0\n0\n0\n\n\n\n0\n0\n0\n\\(\\epsilon_{22}\\epsilon_{21}\\)\n\\(\\epsilon_{22}^2\\)\n\\(\\epsilon_{22}\\epsilon_{23}\\)\n0\n0\n0\n\n\n\n0\n0\n0\n\\(\\epsilon_{23}\\epsilon_{21}\\)\n\\(\\epsilon_{23}\\epsilon_{22}\\)\n\\(\\epsilon_{23}^2\\)\n0\n0\n0\n\n\nFirm 3\n0\n0\n0\n0\n0\n0\n\\(\\epsilon_{31}^2\\)\n\\(\\epsilon_{31}\\epsilon_{32}\\)\n\\(\\epsilon_{31}\\epsilon_{33}\\)\n\n\n\n0\n0\n0\n0\n0\n0\n\\(\\epsilon_{32}\\epsilon_{31}\\)\n\\(\\epsilon_{32}^2\\)\n\\(\\epsilon_{32}\\epsilon_{33}\\)\n\n\n\n0\n0\n0\n0\n0\n0\n\\(\\epsilon_{33}\\epsilon_{31}\\)\n\\(\\epsilon_{33}\\epsilon_{32}\\)\n\\(\\epsilon_{33}^2\\)\n\n\n\nIf you assume that the errors are correlated within the observations of a firm, and across firms within each time period, you can use standard errors clustered by firm and year. In this case, the errors have the following structure:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirm 1\n\n\nFirm 2\n\n\nFirm 3\n\n\n\n\n\nFirm 1\n\\(\\epsilon_{11}^2\\)\n\\(\\epsilon_{11}\\epsilon_{12}\\)\n\\(\\epsilon_{11}\\epsilon_{13}\\)\n\\(\\epsilon_{11}\\epsilon_{21}\\)\n0\n0\n\\(\\epsilon_{11}\\epsilon_{31}\\)\n0\n0\n\n\n\n\\(\\epsilon_{12}\\epsilon_{11}\\)\n\\(\\epsilon_{12}^2\\)\n\\(\\epsilon_{12}\\epsilon_{13}\\)\n0\n\\(\\epsilon_{12}\\epsilon_{22}\\)\n0\n0\n\\(\\epsilon_{12}\\epsilon_{32}\\)\n0\n\n\n\n\\(\\epsilon_{13}\\epsilon_{11}\\)\n\\(\\epsilon_{13}\\epsilon_{12}\\)\n\\(\\epsilon_{13}^2\\)\n0\n0\n\\(\\epsilon_{13}\\epsilon_{23}\\)\n0\n0\n\\(\\epsilon_{13}\\epsilon_{33}\\)\n\n\nFirm 2\n\\(\\epsilon_{21}\\epsilon_{11}\\)\n0\n0\n\\(\\epsilon_{21}^2\\)\n\\(\\epsilon_{21}\\epsilon_{22}\\)\n\\(\\epsilon_{21}\\epsilon_{23}\\)\n\\(\\epsilon_{21}\\epsilon_{31}\\)\n0\n0\n\n\n\n0\n\\(\\epsilon_{22}\\epsilon_{12}\\)\n0\n\\(\\epsilon_{22}\\epsilon_{21}\\)\n\\(\\epsilon_{22}^2\\)\n\\(\\epsilon_{22}\\epsilon_{23}\\)\n0\n\\(\\epsilon_{22}\\epsilon_{32}\\)\n0\n\n\n\n0\n0\n\\(\\epsilon_{23}\\epsilon_{13}\\)\n\\(\\epsilon_{23}\\epsilon_{21}\\)\n\\(\\epsilon_{23}\\epsilon_{22}\\)\n\\(\\epsilon_{23}^2\\)\n0\n0\n\\(\\epsilon_{23}\\epsilon_{33}\\)\n\n\nFirm 3\n\\(\\epsilon_{31}\\epsilon_{11}\\)\n0\n0\n\\(\\epsilon_{31}\\epsilon_{21}\\)\n0\n0\n\\(\\epsilon_{31}^2\\)\n\\(\\epsilon_{31}\\epsilon_{32}\\)\n\\(\\epsilon_{31}\\epsilon_{33}\\)\n\n\n\n0\n\\(\\epsilon_{32}\\epsilon_{12}\\)\n0\n0\n\\(\\epsilon_{32}\\epsilon_{22}\\)\n0\n\\(\\epsilon_{32}\\epsilon_{31}\\)\n\\(\\epsilon_{32}^2\\)\n\\(\\epsilon_{32}\\epsilon_{33}\\)\n\n\n\n0\n0\n\\(\\epsilon_{33}\\epsilon_{13}\\)\n0\n0\n\\(\\epsilon_{33}\\epsilon_{23}\\)\n\\(\\epsilon_{33}\\epsilon_{31}\\)\n\\(\\epsilon_{33}\\epsilon_{32}\\)\n\\(\\epsilon_{33}^2\\)\n\n\n\nYou can easily estimate clustered standard errors with the PanelOLS class by passing cov_type=\"clustered\" and the entity_effects and time_effects arguments to fit() method. The following code estimates the OLS coefficients and standard errors clustered by firm, year, and firm and year:\n\n# Firm only\nres = mod.fit(\n    cov_type=\"clustered\", cluster_entity=True, cluster_time=False, group_debias=True\n)\nres.summary\n\n\nPanelOLS Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.2078\n\n\nEstimator:\nPanelOLS\nR-squared (Between):\n0.2208\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1907\n\n\nDate:\nFri, Jan 19 2024\nR-squared (Overall):\n0.2078\n\n\nTime:\n08:23:25\nLog-likelihood\n-1.057e+04\n\n\nCov. Estimator:\nClustered\n\n\n\n\n\n\nF-statistic:\n1310.7\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4998)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n418.32\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4998)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nIntercept\n0.0297\n0.0670\n0.4429\n0.6579\n-0.1017\n0.1611\n\n\nx\n1.0348\n0.0506\n20.453\n0.0000\n0.9356\n1.1340\n\n\n\n\n\n\n\n# Year only\nres = mod.fit(\n    cov_type=\"clustered\", cluster_entity=False, cluster_time=True, group_debias=True\n)\nres.summary\n\n\nPanelOLS Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.2078\n\n\nEstimator:\nPanelOLS\nR-squared (Between):\n0.2208\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1907\n\n\nDate:\nFri, Jan 19 2024\nR-squared (Overall):\n0.2078\n\n\nTime:\n08:23:25\nLog-likelihood\n-1.057e+04\n\n\nCov. Estimator:\nClustered\n\n\n\n\n\n\nF-statistic:\n1310.7\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4998)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n960.59\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4998)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nIntercept\n0.0297\n0.0234\n1.2691\n0.2045\n-0.0162\n0.0755\n\n\nx\n1.0348\n0.0334\n30.993\n0.0000\n0.9694\n1.1003\n\n\n\n\n\n\n\n# Firm and year\nres = mod.fit(\n    cov_type=\"clustered\", cluster_entity=True, cluster_time=True, group_debias=True\n)\nres.summary\n\n\nPanelOLS Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.2078\n\n\nEstimator:\nPanelOLS\nR-squared (Between):\n0.2208\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1907\n\n\nDate:\nFri, Jan 19 2024\nR-squared (Overall):\n0.2078\n\n\nTime:\n08:23:25\nLog-likelihood\n-1.057e+04\n\n\nCov. Estimator:\nClustered\n\n\n\n\n\n\nF-statistic:\n1310.7\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4998)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n373.33\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4998)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nIntercept\n0.0297\n0.0651\n0.4562\n0.6483\n-0.0979\n0.1572\n\n\nx\n1.0348\n0.0536\n19.322\n0.0000\n0.9298\n1.1398\n\n\n\n\n\n\n\n\n\n\n\n\nDifference with Stata and statsmodels\n\n\n\nBy default, Stata and statsmodels estimators adjust the degrees of freedom when estimating clustered standard errors with small clusters. linearmodels does not do that by default, that is what the group_debias=True parameter is for."
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#panel-regression-with-fixed-effects",
    "href": "posts/panel-ols-standard-errors/index.html#panel-regression-with-fixed-effects",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "Panel regression with fixed effects",
    "text": "Panel regression with fixed effects\nIt is common in finance research to control for entity fixed effects to capture unobserved heterogeneity across entities and for time fixed effects to capture unobserved heterogeneity across time. For example, in a panel of firms, we can control for firm fixed effects to capture unobserved firm-specific characteristics that are constant over time. These fixed effects correspond to the \\(\\alpha_i\\) and \\(\\alpha_t\\) in our panel regression:\n\\[\ny_{it} =  \\alpha_i + \\alpha_t + x_{it}\\beta + \\epsilon_{it},\n\\]\nThe PanelOLS class can be used to estimate panel regression with fixed effects by adding EntityEffects or TimeEffects to the formula. In theory this is equivalent to adding a dummy variable for each entity or time period (i.e.¬†adding C(firmid) or C(year)), but in practice it is much more efficient because linear models will use a efficient transformation to apply the effetc of the dummy variables without including them in the regression estimation. linearmodels will thus not provide coefficients for the fixed effects. Also, the intercept is usually excluded by default from panel data models because the use of fixed-effects renders it redundant, so linearmodels will not provide an intercept either.\nThe following code estimates the OLS coefficients and standard errors with firm fixed effects, year fixed effects, and firm and year fixed effects, and clustered standard errors along the same dimensions:\n\n# Firm only\nmod_ffe = PanelOLS.from_formula(\"y ~ x + EntityEffects\", df)\nres = mod_ffe.fit(\n    cov_type=\"clustered\", cluster_entity=True, cluster_time=False, group_debias=True\n)\nres.summary\n\n\nPanelOLS Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.1916\n\n\nEstimator:\nPanelOLS\nR-squared (Between):\n0.2187\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1916\n\n\nDate:\nFri, Jan 19 2024\nR-squared (Overall):\n0.2070\n\n\nTime:\n08:23:25\nLog-likelihood\n-8532.8\n\n\nCov. Estimator:\nClustered\n\n\n\n\n\n\nF-statistic:\n1066.3\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4499)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n1035.4\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4499)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nx\n0.9699\n0.0301\n32.177\n0.0000\n0.9108\n1.0290\n\n\n\nF-test for Poolability: 11.372P-value: 0.0000Distribution: F(499,4499)Included effects: Entity\n\n\n\n# Year only\nmod_yfe = PanelOLS.from_formula(\"y ~ x + TimeEffects\", df)\nres = mod_yfe.fit(\n    cov_type=\"clustered\", cluster_entity=False, cluster_time=True, group_debias=True\n)\nres.summary\n\n\nPanelOLS Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.2077\n\n\nEstimator:\nPanelOLS\nR-squared (Between):\n0.2208\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1907\n\n\nDate:\nFri, Jan 19 2024\nR-squared (Overall):\n0.2078\n\n\nTime:\n08:23:25\nLog-likelihood\n-1.057e+04\n\n\nCov. Estimator:\nClustered\n\n\n\n\n\n\nF-statistic:\n1307.5\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4989)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n961.52\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4989)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nx\n1.0351\n0.0334\n31.008\n0.0000\n0.9696\n1.1005\n\n\n\nF-test for Poolability: 0.6799P-value: 0.7279Distribution: F(9,4989)Included effects: Time\n\n\n\n# Firm and year\nmod_fyfe = PanelOLS.from_formula(\"y ~ x + EntityEffects + TimeEffects\", df)\nres = mod_fyfe.fit(\n    cov_type=\"clustered\", cluster_entity=True, cluster_time=True, group_debias=True\n)\nres.summary\n\n\nPanelOLS Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.1913\n\n\nEstimator:\nPanelOLS\nR-squared (Between):\n0.2187\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1916\n\n\nDate:\nFri, Jan 19 2024\nR-squared (Overall):\n0.2070\n\n\nTime:\n08:23:25\nLog-likelihood\n-8525.9\n\n\nCov. Estimator:\nClustered\n\n\n\n\n\n\nF-statistic:\n1062.0\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4490)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n972.96\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4490)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nx\n0.9700\n0.0311\n31.192\n0.0000\n0.9091\n1.0310\n\n\n\nF-test for Poolability: 11.203P-value: 0.0000Distribution: F(508,4490)Included effects: Entity, Time"
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#driscoll-kraay-standard-errors",
    "href": "posts/panel-ols-standard-errors/index.html#driscoll-kraay-standard-errors",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "Driscoll-Kraay standard errors",
    "text": "Driscoll-Kraay standard errors\nThe Driscoll-Kraay standard errors estimator is a heteroskedasticity-robust standard errors estimator that is robust to serial correlation in the errors. This is particularly important in datasets where the assumption that observations are independent across cross-sections may not hold. See Driscoll and Kraay (1998) for more details.\nTo use the Driscoll-Kraay standard errors estimator, you need to pass the following arguments to the fit() method:\n\ncov_type=\"kernel\": To use the Driscoll-Kraay HAC estimator.\nkernel=\"bartlett\": The kernel to use. Bartlett is the kernel used by the Newey-West estimator. linearmodels also supports the Parzen (parzen) and the Quadratic Spectral (qs) kernels.\nbandwith=3: the number of lags to use, automatically computed if not specified.\n\n\nres = mod.fit(cov_type=\"kernel\", kernel=\"bartlett\", bandwidth=3)\nres.summary\n\n\nPanelOLS Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.2078\n\n\nEstimator:\nPanelOLS\nR-squared (Between):\n0.2208\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1907\n\n\nDate:\nSat, Jan 20 2024\nR-squared (Overall):\n0.2078\n\n\nTime:\n07:01:02\nLog-likelihood\n-1.057e+04\n\n\nCov. Estimator:\nDriscoll-Kraay\n\n\n\n\n\n\nF-statistic:\n1310.7\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4998)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n1708.6\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4998)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nIntercept\n0.0297\n0.0218\n1.3622\n0.1732\n-0.0130\n0.0724\n\n\nx\n1.0348\n0.0250\n41.335\n0.0000\n0.9858\n1.0839"
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#fama-macbeth-coefficients-and-standard-errors",
    "href": "posts/panel-ols-standard-errors/index.html#fama-macbeth-coefficients-and-standard-errors",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "Fama-MacBeth coefficients and standard errors",
    "text": "Fama-MacBeth coefficients and standard errors\nThe Fama-MacBeth regression, introduced in Fama and MacBeth (1973), is a robust method for estimating financial models in the context of panel data in empirical finance research that is effective in dealing with cross-sectional correlation and heteroskedasticity. This technique involves two key steps: For our model, we would first estimate the following cross-sectional regression for each time period \\(t\\):\n\\[\ny_{it} =  \\alpha_t + x_{it}\\beta + \\epsilon_{it},\n\\]\nand then average the coefficients \\(\\beta\\) over all time periods to provide final estimates:\n\\[\n\\bar{\\beta} = \\frac{1}{T} \\sum_{t=1}^{T} \\beta_t.\n\\]\nThe covariance matrix can then be computed as:\n\\[\n\\Sigma = \\frac{1}{T-1} \\sum_{t=1}^{T} (\\beta_t - \\bar{\\beta})(\\beta_t - \\bar{\\beta})'.\n\\]\nlinearmodels provides a FamaMacBeth class that can be used to estimate Fama-MacBeth regressions. The following code estimates the Fama-MacBeth coefficients and standard errors:\n\nfrom linearmodels import FamaMacBeth\n\nmod_fm = FamaMacBeth.from_formula(\"y ~ 1 + x\", df)\nres = mod_fm.fit()\nres.summary\n\n\nFamaMacBeth Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.2078\n\n\nEstimator:\nFamaMacBeth\nR-squared (Between):\n0.2208\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1907\n\n\nDate:\nSat, Jan 20 2024\nR-squared (Overall):\n0.2078\n\n\nTime:\n06:09:49\nLog-likelihood\n-1.057e+04\n\n\nCov. Estimator:\nFama-MacBeth Standard Cov\n\n\n\n\n\n\nF-statistic:\n1310.7\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4998)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n964.72\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4998)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nIntercept\n0.0313\n0.0234\n1.3392\n0.1806\n-0.0145\n0.0771\n\n\nx\n1.0356\n0.0333\n31.060\n0.0000\n0.9702\n1.1010"
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#newey-west-standard-errors",
    "href": "posts/panel-ols-standard-errors/index.html#newey-west-standard-errors",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "Newey-West standard errors",
    "text": "Newey-West standard errors\nIt is common in practice to use Newey-West standard errors (introduced in Newey and West 1987) instead of the standard errors above in Fama-MacBeth regressions to account for heteroskedasticity and autocorrelation in the residuals.\nTo use Newey-West standard errors, you can pass the following arguments to the fit() method:\n\ncov_type=\"kernel\": To use HAC standard errors. See the documentation on Kernel (HAC) for more details.\nkernel=\"bartlett\": The Newey-West estimator uses the Bartlett kernel. linearmodels also supports the Parzen (parzen) and the Quadratic Spectral (qs) kernels.\nbandwith=3: the number of lags to use, automatically computed if not specified.\n\n\nfm_res = fm_mod.fit(cov_type=\"kernel\", kernel=\"bartlett\", bandwidth=3)\nfm_res.summary\n\n\nFamaMacBeth Estimation Summary\n\n\nDep. Variable:\ny\nR-squared:\n0.2078\n\n\nEstimator:\nFamaMacBeth\nR-squared (Between):\n0.2208\n\n\nNo. Observations:\n5000\nR-squared (Within):\n0.1907\n\n\nDate:\nSat, Jan 20 2024\nR-squared (Overall):\n0.2078\n\n\nTime:\n06:34:46\nLog-likelihood\n-1.057e+04\n\n\nCov. Estimator:\nFama-MacBeth Kernel Cov\n\n\n\n\n\n\nF-statistic:\n1310.7\n\n\nEntities:\n500\nP-value\n0.0000\n\n\nAvg Obs:\n10.0000\nDistribution:\nF(1,4998)\n\n\nMin Obs:\n10.0000\n\n\n\n\nMax Obs:\n10.0000\nF-statistic (robust):\n1440.8\n\n\n\n\nP-value\n0.0000\n\n\nTime periods:\n10\nDistribution:\nF(1,4998)\n\n\nAvg Obs:\n500.00\n\n\n\n\nMin Obs:\n500.00\n\n\n\n\nMax Obs:\n500.00\n\n\n\n\n\n\n\n\n\n\n\n\nParameter Estimates\n\n\n\nParameter\nStd. Err.\nT-stat\nP-value\nLower CI\nUpper CI\n\n\nIntercept\n0.0313\n0.0224\n1.3934\n0.1636\n-0.0127\n0.0753\n\n\nx\n1.0356\n0.0273\n37.958\n0.0000\n0.9821\n1.0891"
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#cheat-sheet",
    "href": "posts/panel-ols-standard-errors/index.html#cheat-sheet",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "Cheat sheet",
    "text": "Cheat sheet\nThe following table summarizes the standard errors estimators available in linearmodels and their corresponding methods:\nfrom linearmodels import PanelOLS\n\n# Model with constant\nmod_cst = PanelOLS.from_formula(\"y ~ 1 + x1 + x2\", data)\n# Non-robust errors (regular OLS)\nres = mod_cst.fit()\n# White standard errors (heteroskedasticity-robust)\nres = mod_cst.fit(cov_type=\"robust\")\n\n# Clustered standard errors\n# By entity (firm)\nres = mod_cst.fit(\n    cov_type=\"clustered\", cluster_entity=True, cluster_time=False, group_debias=True\n)\n# By time (year)\nres = mod_cst.fit(\n    cov_type=\"clustered\", cluster_entity=False, cluster_time=True, group_debias=True\n)\n# By entity and time\nres = mod_cst.fit(\n    cov_type=\"clustered\", cluster_entity=True, cluster_time=True, group_debias=True\n)\n\n# Fixed effects models\n# Model with entity (firm) fixed effects\nmod_fe = PanelOLS.from_formula(\"y ~ x1 + x2 + EntityEffects\", data)\n# Model with time (year) fixed effects\nmod_fe = PanelOLS.from_formula(\"y ~ x1 + x2 + TimeEffects\", data)\n# Model with entity and time fixed effects\nmod_fe = PanelOLS.from_formula(\"y ~ x1 + x2 + EntityEffects+ TimeEffects\", data)\n\n# To cluster standard errors by entity and time, the usage is the same as above,\n# but applied to the FE model.\n\n# By entity (firm)\nres = mod_fe.fit(\n    cov_type=\"clustered\", cluster_entity=True, cluster_time=False, group_debias=True\n)\n# By time (year)\nres = mod_fe.fit(\n    cov_type=\"clustered\", cluster_entity=False, cluster_time=True, group_debias=True\n)\n# By entity and time\nres = mod_fe.fit(\n    cov_type=\"clustered\", cluster_entity=True, cluster_time=True, group_debias=True\n)\n\n# Driscoll-Kraay standard errors\nres = mod_cst.fit(cov_type=\"kernel\", kernel=\"bartlett\", bandwidth=3)\n\n# Fama-MacBeth regressions\nfrom linearmodels import FamaMacBeth\n\nmod_fm = FamaMacBeth.from_formula(\"y ~ 1 + x1 + x2\", data)\n# Non-adjusted standard errors\nres = mod_fm.fit()\n# Newey-West standard errors with 3 lags\nres = mod_fm.fit(cov_type=\"kernel\", kernel=\"bartlett\", bandwidth=3)"
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#learn-more",
    "href": "posts/panel-ols-standard-errors/index.html#learn-more",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "Learn more",
    "text": "Learn more\nTo learn more about the linearmodels library, I recommend reading the documentation, especially the section on panel data model estimation.\nUsing a powerful tool like linearmodels can help you save time and avoid errors when estimating panel data models. However, it is important to understand the underlying econometric theory. If you are interested in learning more about panel data models and their associated standard error, I recommend reading the Petersen (2008) paper or watching the talk he gave at the 2008 FMA Annual meetings."
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#references",
    "href": "posts/panel-ols-standard-errors/index.html#references",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "References",
    "text": "References\n\n\nDriscoll, John C, and Aart C Kraay. 1998. ‚ÄúConsistent Covariance Matrix Estimation with Spatially Dependent Panel Data.‚Äù Review of Economics and Statistics 80 (4): 549‚Äì60. https://www.mitpressjournals.org/doi/abs/10.1162/003465398557825.\n\n\nFama, Eugene F, and James D MacBeth. 1973. ‚ÄúRisk, Return, and Equilibrium: Empirical Tests.‚Äù Journal of Political Economy 81 (3): 607‚Äì36. https://www.journals.uchicago.edu/doi/abs/10.1086/260061.\n\n\nNewey, Whitney K, and Kenneth D West. 1987. ‚ÄúA Simple, Positive Semi-Definite, Heteroskedasticity and Autocorrelation Consistent Covariance Matrix.‚Äù Econometrica 55 (3): 703‚Äì8. https://www.jstor.org/stable/1913610.\n\n\nPetersen, Mitchell A. 2008. ‚ÄúEstimating Standard Errors in Finance Panel Data Sets: Comparing Approaches.‚Äù The Review of Financial Studies 22 (1): 435‚Äì80. https://academic.oup.com/rfs/article-abstract/22/1/435/1585940."
  },
  {
    "objectID": "posts/panel-ols-standard-errors/index.html#footnotes",
    "href": "posts/panel-ols-standard-errors/index.html#footnotes",
    "title": "Estimating standard errors in panel data with Python and linearmodels",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nCredit: the two tables are taken from Petersen (2008).‚Ü©Ô∏é"
  },
  {
    "objectID": "posts/python-basics-tutorial/index.html",
    "href": "posts/python-basics-tutorial/index.html",
    "title": "Python basic tutorial",
    "section": "",
    "text": "I posted a tutorial on the basics of the Python syntax. This tutorial has been updated for Python 3.12, and covers the basics of the Python syntax. It is intended for beginners and is a good starting point for those who want to learn Python. It does not cover the whole syntax, only the elements that I find essential to get started with data analysis and empirical research using Python. After the tutorial, you should have enough knowledge to start learning the modules that are relevant to data analysis such as pandas, numpy, matplotlib, etc.\nI am in the process of recording a video tutorial that will be posted on my YouTube channel. I will post the link to the video here once it is ready.\nIf you haven‚Äôt done so already, I recommend you to install Python on your computer. You can find instructions on how to do so here.\n\n\n\nReuseCC BY-NC-SA 4.0"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Vincent Codes Finance",
    "section": "",
    "text": "Estimating standard errors in panel data with Python and linearmodels\n\n\n\n\n\n\n\nPython\n\n\nEconometrics\n\n\nLinearmodels\n\n\n\n\n\n\n\n\n\n\n\nJan 21, 2024\n\n\n\n\n\n\n  \n\n\n\n\nPython basic tutorial\n\n\n\n\n\n\n\nPython\n\n\nTutorial\n\n\nBeginner\n\n\n\n\n\n\n\n\n\n\n\nJan 7, 2024\n\n\n\n\n\n\n  \n\n\n\n\nInstalling Python 3.12\n\n\n\n\n\n\n\nPython\n\n\nTutorial\n\n\nBeginner\n\n\n\n\n\n\n\n\n\n\n\nJan 3, 2024\n\n\n\n\n\n\n  \n\n\n\n\nNew Year, new blog\n\n\n\n\n\n\n\nNews\n\n\n\n\n\n\n\n\n\n\n\nJan 1, 2024\n\n\n\n\n\n\nNo matching items\n\nReuseCC BY-NC-SA 4.0"
  }
]